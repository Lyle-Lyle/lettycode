/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@umijs";
exports.ids = ["vendor-chunks/@umijs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@umijs/route-utils/es/getFlatMenus/getFlatMenus.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@umijs/route-utils/es/getFlatMenus/getFlatMenus.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getFlatMenus: () => (/* binding */ getFlatMenus)\n/* harmony export */ });\n/* harmony import */ var _transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transformRoute/transformRoute */ \"(ssr)/./node_modules/@umijs/route-utils/es/transformRoute/transformRoute.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n/**\n * 获取打平的 menuData\n * 以 path 为 key\n * @param menuData\n */\n\nvar getFlatMenus = function getFlatMenus() {\n  var menuData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var menus = {};\n  menuData.forEach(function (mapItem) {\n    var item = _objectSpread({}, mapItem);\n\n    if (!item || !item.key) {\n      return;\n    }\n\n    if (!item.children && item[_transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_0__.childrenPropsName]) {\n      item.children = item[_transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_0__.childrenPropsName];\n      delete item[_transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_0__.childrenPropsName];\n    }\n\n    var routerChildren = item.children || [];\n    menus[(0,_transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_0__.stripQueryStringAndHashFromPath)(item.path || item.key || '/')] = _objectSpread({}, item);\n    menus[item.key || item.path || '/'] = _objectSpread({}, item);\n\n    if (routerChildren) {\n      menus = _objectSpread(_objectSpread({}, menus), getFlatMenus(routerChildren));\n    }\n  });\n  return menus;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getFlatMenus);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3JvdXRlLXV0aWxzL2VzL2dldEZsYXRNZW51cy9nZXRGbGF0TWVudXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsNENBQTRDLG9LQUFvSyxtRkFBbUYsS0FBSzs7QUFFMWUsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRTlGO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsNkVBQWlCO0FBQ2hELDJCQUEyQiw2RUFBaUI7QUFDNUMsa0JBQWtCLDZFQUFpQjtBQUNuQzs7QUFFQTtBQUNBLFVBQVUsK0ZBQStCLGtEQUFrRDtBQUMzRiwwREFBMEQ7O0FBRTFEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpRUFBZSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGV0dHljb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B1bWlqcy9yb3V0ZS11dGlscy9lcy9nZXRGbGF0TWVudXMvZ2V0RmxhdE1lbnVzLmpzP2FiZTgiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IHsgc3RyaXBRdWVyeVN0cmluZ0FuZEhhc2hGcm9tUGF0aCwgY2hpbGRyZW5Qcm9wc05hbWUgfSBmcm9tICcuLi90cmFuc2Zvcm1Sb3V0ZS90cmFuc2Zvcm1Sb3V0ZSc7XG4vKipcbiAqIOiOt+WPluaJk+W5s+eahCBtZW51RGF0YVxuICog5LulIHBhdGgg5Li6IGtleVxuICogQHBhcmFtIG1lbnVEYXRhXG4gKi9cblxuZXhwb3J0IHZhciBnZXRGbGF0TWVudXMgPSBmdW5jdGlvbiBnZXRGbGF0TWVudXMoKSB7XG4gIHZhciBtZW51RGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHZhciBtZW51cyA9IHt9O1xuICBtZW51RGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChtYXBJdGVtKSB7XG4gICAgdmFyIGl0ZW0gPSBfb2JqZWN0U3ByZWFkKHt9LCBtYXBJdGVtKTtcblxuICAgIGlmICghaXRlbSB8fCAhaXRlbS5rZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWl0ZW0uY2hpbGRyZW4gJiYgaXRlbVtjaGlsZHJlblByb3BzTmFtZV0pIHtcbiAgICAgIGl0ZW0uY2hpbGRyZW4gPSBpdGVtW2NoaWxkcmVuUHJvcHNOYW1lXTtcbiAgICAgIGRlbGV0ZSBpdGVtW2NoaWxkcmVuUHJvcHNOYW1lXTtcbiAgICB9XG5cbiAgICB2YXIgcm91dGVyQ2hpbGRyZW4gPSBpdGVtLmNoaWxkcmVuIHx8IFtdO1xuICAgIG1lbnVzW3N0cmlwUXVlcnlTdHJpbmdBbmRIYXNoRnJvbVBhdGgoaXRlbS5wYXRoIHx8IGl0ZW0ua2V5IHx8ICcvJyldID0gX29iamVjdFNwcmVhZCh7fSwgaXRlbSk7XG4gICAgbWVudXNbaXRlbS5rZXkgfHwgaXRlbS5wYXRoIHx8ICcvJ10gPSBfb2JqZWN0U3ByZWFkKHt9LCBpdGVtKTtcblxuICAgIGlmIChyb3V0ZXJDaGlsZHJlbikge1xuICAgICAgbWVudXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG1lbnVzKSwgZ2V0RmxhdE1lbnVzKHJvdXRlckNoaWxkcmVuKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1lbnVzO1xufTtcbmV4cG9ydCBkZWZhdWx0IGdldEZsYXRNZW51czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@umijs/route-utils/es/getFlatMenus/getFlatMenus.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@umijs/route-utils/es/getMatchMenu/getMatchMenu.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@umijs/route-utils/es/getMatchMenu/getMatchMenu.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getMatchMenu: () => (/* binding */ getMatchMenu),\n/* harmony export */   getMenuMatches: () => (/* binding */ getMenuMatches)\n/* harmony export */ });\n/* harmony import */ var _path_to_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../path-to-regexp */ \"(ssr)/./node_modules/@umijs/route-utils/es/path-to-regexp.js\");\n/* harmony import */ var _getFlatMenus_getFlatMenus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../getFlatMenus/getFlatMenus */ \"(ssr)/./node_modules/@umijs/route-utils/es/getFlatMenus/getFlatMenus.js\");\n/* harmony import */ var _transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transformRoute/transformRoute */ \"(ssr)/./node_modules/@umijs/route-utils/es/transformRoute/transformRoute.js\");\n//@ts-ignore\n\n\n\nvar getMenuMatches = function getMenuMatches() {\n  var flatMenuKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var path = arguments.length > 1 ? arguments[1] : undefined;\n  var exact = arguments.length > 2 ? arguments[2] : undefined;\n  return flatMenuKeys.filter(function (item) {\n    if (item === '/' && path === '/') {\n      return true;\n    }\n\n    if (item !== '/' && item !== '/*' && item && !(0,_transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_2__.isUrl)(item)) {\n      var pathKey = (0,_transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_2__.stripQueryStringAndHashFromPath)(item);\n\n      try {\n        // exact\n        if (exact) {\n          if ((0,_path_to_regexp__WEBPACK_IMPORTED_MODULE_0__.pathToRegexp)(\"\".concat(pathKey)).test(path)) {\n            return true;\n          }\n        } // /a\n\n\n        if ((0,_path_to_regexp__WEBPACK_IMPORTED_MODULE_0__.pathToRegexp)(\"\".concat(pathKey), []).test(path)) {\n          return true;\n        } // /a/b/b\n\n\n        if ((0,_path_to_regexp__WEBPACK_IMPORTED_MODULE_0__.pathToRegexp)(\"\".concat(pathKey, \"/(.*)\")).test(path)) {\n          return true;\n        }\n      } catch (error) {// console.log(error, path);\n      }\n    }\n\n    return false;\n  }).sort(function (a, b) {\n    // 如果完全匹配放到最后面\n    if (a === path) {\n      return 10;\n    }\n\n    if (b === path) {\n      return -10;\n    }\n\n    return a.substr(1).split('/').length - b.substr(1).split('/').length;\n  });\n};\n/**\n * 获取当前的选中菜单列表\n * @param pathname\n * @param menuData\n * @returns MenuDataItem[]\n */\n\nvar getMatchMenu = function getMatchMenu(pathname, menuData,\n/**\n * 要不要展示全部的 key\n */\nfullKeys, exact) {\n  var flatMenus = (0,_getFlatMenus_getFlatMenus__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(menuData);\n  var flatMenuKeys = Object.keys(flatMenus);\n  var menuPathKeys = getMenuMatches(flatMenuKeys, pathname || '/', exact);\n\n  if (!menuPathKeys || menuPathKeys.length < 1) {\n    return [];\n  }\n\n  if (!fullKeys) {\n    menuPathKeys = [menuPathKeys[menuPathKeys.length - 1]];\n  }\n\n  return menuPathKeys.map(function (menuPathKey) {\n    var menuItem = flatMenus[menuPathKey] || {\n      pro_layout_parentKeys: '',\n      key: ''\n    }; // 去重\n\n    var map = new Map();\n    var parentItems = (menuItem.pro_layout_parentKeys || []).map(function (key) {\n      if (map.has(key)) {\n        return null;\n      }\n\n      map.set(key, true);\n      return flatMenus[key];\n    }).filter(function (item) {\n      return item;\n    });\n\n    if (menuItem.key) {\n      parentItems.push(menuItem);\n    }\n\n    return parentItems;\n  }).flat(1);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getMatchMenu);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3JvdXRlLXV0aWxzL2VzL2dldE1hdGNoTWVudS9nZXRNYXRjaE1lbnUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDaUQ7QUFDTTtBQUNtQztBQUNuRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCxxRUFBSztBQUN2RCxvQkFBb0IsK0ZBQStCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZEQUFZO0FBQzFCO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVixZQUFZLDZEQUFZO0FBQ3hCO0FBQ0EsVUFBVTs7O0FBR1YsWUFBWSw2REFBWTtBQUN4QjtBQUNBO0FBQ0EsUUFBUSxlQUFlO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0VBQVc7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlFQUFlLFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZXR0eWNvZGUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3JvdXRlLXV0aWxzL2VzL2dldE1hdGNoTWVudS9nZXRNYXRjaE1lbnUuanM/N2FmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL0B0cy1pZ25vcmVcbmltcG9ydCB7IHBhdGhUb1JlZ2V4cCB9IGZyb20gJy4uL3BhdGgtdG8tcmVnZXhwJztcbmltcG9ydCBnZXRGbGF0TWVudSBmcm9tICcuLi9nZXRGbGF0TWVudXMvZ2V0RmxhdE1lbnVzJztcbmltcG9ydCB7IGlzVXJsLCBzdHJpcFF1ZXJ5U3RyaW5nQW5kSGFzaEZyb21QYXRoIH0gZnJvbSAnLi4vdHJhbnNmb3JtUm91dGUvdHJhbnNmb3JtUm91dGUnO1xuZXhwb3J0IHZhciBnZXRNZW51TWF0Y2hlcyA9IGZ1bmN0aW9uIGdldE1lbnVNYXRjaGVzKCkge1xuICB2YXIgZmxhdE1lbnVLZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGV4YWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiBmbGF0TWVudUtleXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT09ICcvJyAmJiBwYXRoID09PSAnLycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpdGVtICE9PSAnLycgJiYgaXRlbSAhPT0gJy8qJyAmJiBpdGVtICYmICFpc1VybChpdGVtKSkge1xuICAgICAgdmFyIHBhdGhLZXkgPSBzdHJpcFF1ZXJ5U3RyaW5nQW5kSGFzaEZyb21QYXRoKGl0ZW0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBleGFjdFxuICAgICAgICBpZiAoZXhhY3QpIHtcbiAgICAgICAgICBpZiAocGF0aFRvUmVnZXhwKFwiXCIuY29uY2F0KHBhdGhLZXkpKS50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gL2FcblxuXG4gICAgICAgIGlmIChwYXRoVG9SZWdleHAoXCJcIi5jb25jYXQocGF0aEtleSksIFtdKS50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gL2EvYi9iXG5cblxuICAgICAgICBpZiAocGF0aFRvUmVnZXhwKFwiXCIuY29uY2F0KHBhdGhLZXksIFwiLyguKilcIikpLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBjb25zb2xlLmxvZyhlcnJvciwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8g5aaC5p6c5a6M5YWo5Yy56YWN5pS+5Yiw5pyA5ZCO6Z2iXG4gICAgaWYgKGEgPT09IHBhdGgpIHtcbiAgICAgIHJldHVybiAxMDtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gcGF0aCkge1xuICAgICAgcmV0dXJuIC0xMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYS5zdWJzdHIoMSkuc3BsaXQoJy8nKS5sZW5ndGggLSBiLnN1YnN0cigxKS5zcGxpdCgnLycpLmxlbmd0aDtcbiAgfSk7XG59O1xuLyoqXG4gKiDojrflj5blvZPliY3nmoTpgInkuK3oj5zljZXliJfooahcbiAqIEBwYXJhbSBwYXRobmFtZVxuICogQHBhcmFtIG1lbnVEYXRhXG4gKiBAcmV0dXJucyBNZW51RGF0YUl0ZW1bXVxuICovXG5cbmV4cG9ydCB2YXIgZ2V0TWF0Y2hNZW51ID0gZnVuY3Rpb24gZ2V0TWF0Y2hNZW51KHBhdGhuYW1lLCBtZW51RGF0YSxcbi8qKlxuICog6KaB5LiN6KaB5bGV56S65YWo6YOo55qEIGtleVxuICovXG5mdWxsS2V5cywgZXhhY3QpIHtcbiAgdmFyIGZsYXRNZW51cyA9IGdldEZsYXRNZW51KG1lbnVEYXRhKTtcbiAgdmFyIGZsYXRNZW51S2V5cyA9IE9iamVjdC5rZXlzKGZsYXRNZW51cyk7XG4gIHZhciBtZW51UGF0aEtleXMgPSBnZXRNZW51TWF0Y2hlcyhmbGF0TWVudUtleXMsIHBhdGhuYW1lIHx8ICcvJywgZXhhY3QpO1xuXG4gIGlmICghbWVudVBhdGhLZXlzIHx8IG1lbnVQYXRoS2V5cy5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKCFmdWxsS2V5cykge1xuICAgIG1lbnVQYXRoS2V5cyA9IFttZW51UGF0aEtleXNbbWVudVBhdGhLZXlzLmxlbmd0aCAtIDFdXTtcbiAgfVxuXG4gIHJldHVybiBtZW51UGF0aEtleXMubWFwKGZ1bmN0aW9uIChtZW51UGF0aEtleSkge1xuICAgIHZhciBtZW51SXRlbSA9IGZsYXRNZW51c1ttZW51UGF0aEtleV0gfHwge1xuICAgICAgcHJvX2xheW91dF9wYXJlbnRLZXlzOiAnJyxcbiAgICAgIGtleTogJydcbiAgICB9OyAvLyDljrvph41cblxuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHBhcmVudEl0ZW1zID0gKG1lbnVJdGVtLnByb19sYXlvdXRfcGFyZW50S2V5cyB8fCBbXSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG1hcC5zZXQoa2V5LCB0cnVlKTtcbiAgICAgIHJldHVybiBmbGF0TWVudXNba2V5XTtcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pO1xuXG4gICAgaWYgKG1lbnVJdGVtLmtleSkge1xuICAgICAgcGFyZW50SXRlbXMucHVzaChtZW51SXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudEl0ZW1zO1xuICB9KS5mbGF0KDEpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGdldE1hdGNoTWVudTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@umijs/route-utils/es/getMatchMenu/getMatchMenu.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@umijs/route-utils/es/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@umijs/route-utils/es/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFlatMenus: () => (/* reexport safe */ _getFlatMenus_getFlatMenus__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   getMatchMenu: () => (/* reexport safe */ _getMatchMenu_getMatchMenu__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   transformRoute: () => (/* reexport safe */ _transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _transformRoute_transformRoute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transformRoute/transformRoute */ \"(ssr)/./node_modules/@umijs/route-utils/es/transformRoute/transformRoute.js\");\n/* harmony import */ var _getFlatMenus_getFlatMenus__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getFlatMenus/getFlatMenus */ \"(ssr)/./node_modules/@umijs/route-utils/es/getFlatMenus/getFlatMenus.js\");\n/* harmony import */ var _getMatchMenu_getMatchMenu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getMatchMenu/getMatchMenu */ \"(ssr)/./node_modules/@umijs/route-utils/es/getMatchMenu/getMatchMenu.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3JvdXRlLXV0aWxzL2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0RTtBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGV0dHljb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B1bWlqcy9yb3V0ZS11dGlscy9lcy9pbmRleC5qcz9jZGI0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgdHJhbnNmb3JtUm91dGUgfSBmcm9tICcuL3RyYW5zZm9ybVJvdXRlL3RyYW5zZm9ybVJvdXRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0RmxhdE1lbnVzIH0gZnJvbSAnLi9nZXRGbGF0TWVudXMvZ2V0RmxhdE1lbnVzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZ2V0TWF0Y2hNZW51IH0gZnJvbSAnLi9nZXRNYXRjaE1lbnUvZ2V0TWF0Y2hNZW51JzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@umijs/route-utils/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@umijs/route-utils/es/path-to-regexp.js":
/*!**************************************************************!*\
  !*** ./node_modules/@umijs/route-utils/es/path-to-regexp.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.pathToRegexp = exports.tokensToRegexp = exports.regexpToFunction = exports.match = exports.tokensToFunction = exports.compile = exports.parse = void 0;\n/**\n * Tokenize input string.\n */\n\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n\n  while (i < str.length) {\n    var char = str[i];\n\n    if (char === '*' || char === '+' || char === '?') {\n      tokens.push({\n        type: 'MODIFIER',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === '\\\\') {\n      tokens.push({\n        type: 'ESCAPED_CHAR',\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === '{') {\n      tokens.push({\n        type: 'OPEN',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === '}') {\n      tokens.push({\n        type: 'CLOSE',\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === ':') {\n      var name = '';\n      var j = i + 1;\n\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n\n        if ( // `0-9`\n        code >= 48 && code <= 57 || // `A-Z`\n        code >= 65 && code <= 90 || // `a-z`\n        code >= 97 && code <= 122 || // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError('Missing parameter name at ' + i);\n      tokens.push({\n        type: 'NAME',\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n\n    if (char === '(') {\n      var count = 1;\n      var pattern = '';\n      var j = i + 1;\n\n      if (str[j] === '?') {\n        throw new TypeError('Pattern cannot start with \"?\" at ' + j);\n      }\n\n      while (j < str.length) {\n        if (str[j] === '\\\\') {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === ')') {\n          count--;\n\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === '(') {\n          count++;\n\n          if (str[j + 1] !== '?') {\n            throw new TypeError('Capturing groups are not allowed at ' + j);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError('Unbalanced pattern at ' + i);\n      if (!pattern) throw new TypeError('Missing pattern at ' + i);\n      tokens.push({\n        type: 'PATTERN',\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n\n    tokens.push({\n      type: 'CHAR',\n      index: i,\n      value: str[i++]\n    });\n  }\n\n  tokens.push({\n    type: 'END',\n    index: i,\n    value: ''\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\n\n\nfunction parse(str, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n      prefixes = _a === void 0 ? './' : _a;\n  var defaultPattern = '[^' + escapeString(options.delimiter || '/#?') + ']+?';\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = '';\n\n  var tryConsume = function tryConsume(type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  var mustConsume = function mustConsume(type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n        nextType = _a.type,\n        index = _a.index;\n    throw new TypeError('Unexpected ' + nextType + ' at ' + index + ', expected ' + type);\n  };\n\n  var consumeText = function consumeText() {\n    var result = '';\n    var value; // tslint:disable-next-line\n\n    while (value = tryConsume('CHAR') || tryConsume('ESCAPED_CHAR')) {\n      result += value;\n    }\n\n    return result;\n  };\n\n  while (i < tokens.length) {\n    var char = tryConsume('CHAR');\n    var name = tryConsume('NAME');\n    var pattern = tryConsume('PATTERN');\n\n    if (name || pattern) {\n      var prefix = char || '';\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = '';\n      }\n\n      if (path) {\n        result.push(path);\n        path = '';\n      }\n\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: '',\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume('MODIFIER') || ''\n      });\n      continue;\n    }\n\n    var value = char || tryConsume('ESCAPED_CHAR');\n\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = '';\n    }\n\n    var open = tryConsume('OPEN');\n\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume('NAME') || '';\n      var pattern_1 = tryConsume('PATTERN') || '';\n      var suffix = consumeText();\n      mustConsume('CLOSE');\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : ''),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume('MODIFIER') || ''\n      });\n      continue;\n    }\n\n    mustConsume('END');\n  }\n\n  return result;\n}\n\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\nfunction tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var reFlags = flags(options);\n  var _a = options.encode,\n      encode = _a === void 0 ? function (x) {\n    return x;\n  } : _a,\n      _b = options.validate,\n      validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.\n\n  var matches = tokens.map(function (token) {\n    if (_typeof(token) === 'object') {\n      return new RegExp('^(?:' + token.pattern + ')$', reFlags);\n    }\n  });\n  return function (data) {\n    var path = '';\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === '?' || token.modifier === '*';\n      var repeat = token.modifier === '*' || token.modifier === '+';\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but got an array');\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"');\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        var segment = encode(String(value), token);\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but got \"' + segment + '\"');\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n      var typeOfMessage = repeat ? 'an array' : 'a string';\n      throw new TypeError('Expected \"' + token.name + '\" to be ' + typeOfMessage);\n    }\n\n    return path;\n  };\n}\n\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\n\nfunction match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\n\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\n\nfunction regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var _a = options.decode,\n      decode = _a === void 0 ? function (x) {\n    return x;\n  } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n        index = m.index;\n    var params = Object.create(null);\n\n    var _loop_1 = function _loop_1(i) {\n      // tslint:disable-next-line\n      if (m[i] === undefined) return 'continue';\n      var key = keys[i - 1];\n\n      if (key.modifier === '*' || key.modifier === '+') {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\n\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1');\n}\n/**\n * Get the flags for a regexp from the options.\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path; // Use a negative lookahead to match only capturing groups.\n\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: '',\n        suffix: '',\n        modifier: '',\n        pattern: ''\n      });\n    }\n  }\n\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\n\n\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp('(?:' + parts.join('|') + ')', flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\n\n\nfunction tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  }\n\n  var _a = options.strict,\n      strict = _a === void 0 ? false : _a,\n      _b = options.start,\n      start = _b === void 0 ? true : _b,\n      _c = options.end,\n      end = _c === void 0 ? true : _c,\n      _d = options.encode,\n      encode = _d === void 0 ? function (x) {\n    return x;\n  } : _d;\n  var endsWith = '[' + escapeString(options.endsWith || '') + ']|$';\n  var delimiter = '[' + escapeString(options.delimiter || '/#?') + ']';\n  var route = start ? '^' : ''; // Iterate over the tokens and create our regexp string.\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    if (typeof token === 'string') {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === '+' || token.modifier === '*') {\n            var mod = token.modifier === '*' ? '?' : '';\n            route += '(?:' + prefix + '((?:' + token.pattern + ')(?:' + suffix + prefix + '(?:' + token.pattern + '))*)' + suffix + ')' + mod;\n          } else {\n            route += '(?:' + prefix + '(' + token.pattern + ')' + suffix + ')' + token.modifier;\n          }\n        } else {\n          route += '(' + token.pattern + ')' + token.modifier;\n        }\n      } else {\n        route += '(?:' + prefix + suffix + ')' + token.modifier;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += delimiter + '?';\n    route += !options.endsWith ? '$' : '(?=' + endsWith + ')';\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === 'string' ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : // tslint:disable-next-line\n    endToken === undefined;\n\n    if (!strict) {\n      route += '(?:' + delimiter + '(?=' + endsWith + '))?';\n    }\n\n    if (!isEndDelimited) {\n      route += '(?=' + delimiter + '|' + endsWith + ')';\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\n\nfunction pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n\nexports.pathToRegexp = pathToRegexp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3JvdXRlLXV0aWxzL2VzL3BhdGgtdG8tcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLHdCQUF3QiwyQkFBMkIsc0dBQXNHLHFCQUFxQixtQkFBbUIsOEhBQThIOztBQUUvVCw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixvQkFBb0IsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxhQUFhLEdBQUcsd0JBQXdCLEdBQUcsZUFBZSxHQUFHLGFBQWE7QUFDcko7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLHNDQUFzQyxzQkFBc0I7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUE0RDtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2xldHR5Y29kZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdW1panMvcm91dGUtdXRpbHMvZXMvcGF0aC10by1yZWdleHAuanM/M2NkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXRoVG9SZWdleHAgPSBleHBvcnRzLnRva2Vuc1RvUmVnZXhwID0gZXhwb3J0cy5yZWdleHBUb0Z1bmN0aW9uID0gZXhwb3J0cy5tYXRjaCA9IGV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IGV4cG9ydHMuY29tcGlsZSA9IGV4cG9ydHMucGFyc2UgPSB2b2lkIDA7XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBsZXhlcihzdHIpIHtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGNoYXIgPSBzdHJbaV07XG5cbiAgICBpZiAoY2hhciA9PT0gJyonIHx8IGNoYXIgPT09ICcrJyB8fCBjaGFyID09PSAnPycpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ01PRElGSUVSJyxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiBzdHJbaSsrXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdFU0NBUEVEX0NIQVInLFxuICAgICAgICBpbmRleDogaSsrLFxuICAgICAgICB2YWx1ZTogc3RyW2krK11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT09ICd7Jykge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnT1BFTicsXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogc3RyW2krK11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT09ICd9Jykge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnQ0xPU0UnLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHN0cltpKytdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFyID09PSAnOicpIHtcbiAgICAgIHZhciBuYW1lID0gJyc7XG4gICAgICB2YXIgaiA9IGkgKyAxO1xuXG4gICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChqKTtcblxuICAgICAgICBpZiAoIC8vIGAwLTlgXG4gICAgICAgIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NyB8fCAvLyBgQS1aYFxuICAgICAgICBjb2RlID49IDY1ICYmIGNvZGUgPD0gOTAgfHwgLy8gYGEtemBcbiAgICAgICAgY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEyMiB8fCAvLyBgX2BcbiAgICAgICAgY29kZSA9PT0gOTUpIHtcbiAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBwYXJhbWV0ZXIgbmFtZSBhdCAnICsgaSk7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdOQU1FJyxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICB9KTtcbiAgICAgIGkgPSBqO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT09ICcoJykge1xuICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgIHZhciBwYXR0ZXJuID0gJyc7XG4gICAgICB2YXIgaiA9IGkgKyAxO1xuXG4gICAgICBpZiAoc3RyW2pdID09PSAnPycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGF0dGVybiBjYW5ub3Qgc3RhcnQgd2l0aCBcIj9cIiBhdCAnICsgaik7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RyW2pdID09PSAnXFxcXCcpIHtcbiAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyW2pdID09PSAnKScpIHtcbiAgICAgICAgICBjb3VudC0tO1xuXG4gICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyW2pdID09PSAnKCcpIHtcbiAgICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09ICc/Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgJyArIGopO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhdHRlcm4gKz0gc3RyW2orK107XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5iYWxhbmNlZCBwYXR0ZXJuIGF0ICcgKyBpKTtcbiAgICAgIGlmICghcGF0dGVybikgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBwYXR0ZXJuIGF0ICcgKyBpKTtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ1BBVFRFUk4nLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHBhdHRlcm5cbiAgICAgIH0pO1xuICAgICAgaSA9IGo7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICB0eXBlOiAnQ0hBUicsXG4gICAgICBpbmRleDogaSxcbiAgICAgIHZhbHVlOiBzdHJbaSsrXVxuICAgIH0pO1xuICB9XG5cbiAgdG9rZW5zLnB1c2goe1xuICAgIHR5cGU6ICdFTkQnLFxuICAgIGluZGV4OiBpLFxuICAgIHZhbHVlOiAnJ1xuICB9KTtcbiAgcmV0dXJuIHRva2Vucztcbn1cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICovXG5cblxuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgdmFyIF9hID0gb3B0aW9ucy5wcmVmaXhlcyxcbiAgICAgIHByZWZpeGVzID0gX2EgPT09IHZvaWQgMCA/ICcuLycgOiBfYTtcbiAgdmFyIGRlZmF1bHRQYXR0ZXJuID0gJ1teJyArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLyM/JykgKyAnXSs/JztcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5ID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuXG4gIHZhciB0cnlDb25zdW1lID0gZnVuY3Rpb24gdHJ5Q29uc3VtZSh0eXBlKSB7XG4gICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKSByZXR1cm4gdG9rZW5zW2krK10udmFsdWU7XG4gIH07XG5cbiAgdmFyIG11c3RDb25zdW1lID0gZnVuY3Rpb24gbXVzdENvbnN1bWUodHlwZSkge1xuICAgIHZhciB2YWx1ZSA9IHRyeUNvbnN1bWUodHlwZSk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHJldHVybiB2YWx1ZTtcbiAgICB2YXIgX2EgPSB0b2tlbnNbaV0sXG4gICAgICAgIG5leHRUeXBlID0gX2EudHlwZSxcbiAgICAgICAgaW5kZXggPSBfYS5pbmRleDtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkICcgKyBuZXh0VHlwZSArICcgYXQgJyArIGluZGV4ICsgJywgZXhwZWN0ZWQgJyArIHR5cGUpO1xuICB9O1xuXG4gIHZhciBjb25zdW1lVGV4dCA9IGZ1bmN0aW9uIGNvbnN1bWVUZXh0KCkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgdmFsdWU7IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuXG4gICAgd2hpbGUgKHZhbHVlID0gdHJ5Q29uc3VtZSgnQ0hBUicpIHx8IHRyeUNvbnN1bWUoJ0VTQ0FQRURfQ0hBUicpKSB7XG4gICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB3aGlsZSAoaSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICB2YXIgY2hhciA9IHRyeUNvbnN1bWUoJ0NIQVInKTtcbiAgICB2YXIgbmFtZSA9IHRyeUNvbnN1bWUoJ05BTUUnKTtcbiAgICB2YXIgcGF0dGVybiA9IHRyeUNvbnN1bWUoJ1BBVFRFUk4nKTtcblxuICAgIGlmIChuYW1lIHx8IHBhdHRlcm4pIHtcbiAgICAgIHZhciBwcmVmaXggPSBjaGFyIHx8ICcnO1xuXG4gICAgICBpZiAocHJlZml4ZXMuaW5kZXhPZihwcmVmaXgpID09PSAtMSkge1xuICAgICAgICBwYXRoICs9IHByZWZpeDtcbiAgICAgICAgcHJlZml4ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICBwYXRoID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIHN1ZmZpeDogJycsXG4gICAgICAgIHBhdHRlcm46IHBhdHRlcm4gfHwgZGVmYXVsdFBhdHRlcm4sXG4gICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKCdNT0RJRklFUicpIHx8ICcnXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGNoYXIgfHwgdHJ5Q29uc3VtZSgnRVNDQVBFRF9DSEFSJyk7XG5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHBhdGggKz0gdmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcmVzdWx0LnB1c2gocGF0aCk7XG4gICAgICBwYXRoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIG9wZW4gPSB0cnlDb25zdW1lKCdPUEVOJyk7XG5cbiAgICBpZiAob3Blbikge1xuICAgICAgdmFyIHByZWZpeCA9IGNvbnN1bWVUZXh0KCk7XG4gICAgICB2YXIgbmFtZV8xID0gdHJ5Q29uc3VtZSgnTkFNRScpIHx8ICcnO1xuICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoJ1BBVFRFUk4nKSB8fCAnJztcbiAgICAgIHZhciBzdWZmaXggPSBjb25zdW1lVGV4dCgpO1xuICAgICAgbXVzdENvbnN1bWUoJ0NMT1NFJyk7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIG5hbWU6IG5hbWVfMSB8fCAocGF0dGVybl8xID8ga2V5KysgOiAnJyksXG4gICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoJ01PRElGSUVSJykgfHwgJydcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbXVzdENvbnN1bWUoJ0VORCcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGUoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uKHRva2Vucywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIHJlRmxhZ3MgPSBmbGFncyhvcHRpb25zKTtcbiAgdmFyIF9hID0gb3B0aW9ucy5lbmNvZGUsXG4gICAgICBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfSA6IF9hLFxuICAgICAgX2IgPSBvcHRpb25zLnZhbGlkYXRlLFxuICAgICAgdmFsaWRhdGUgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iOyAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cblxuICB2YXIgbWF0Y2hlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgaWYgKF90eXBlb2YodG9rZW4pID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW4ucGF0dGVybiArICcpJCcsIHJlRmxhZ3MpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBwYXRoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YSA/IGRhdGFbdG9rZW4ubmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgb3B0aW9uYWwgPSB0b2tlbi5tb2RpZmllciA9PT0gJz8nIHx8IHRva2VuLm1vZGlmaWVyID09PSAnKic7XG4gICAgICB2YXIgcmVwZWF0ID0gdG9rZW4ubW9kaWZpZXIgPT09ICcqJyB8fCB0b2tlbi5tb2RpZmllciA9PT0gJysnO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAob3B0aW9uYWwpIGNvbnRpbnVlO1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcblxuICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgZ290IFwiJyArIHNlZ21lbnQgKyAnXCInKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQgKyB0b2tlbi5zdWZmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGVuY29kZShTdHJpbmcodmFsdWUpLCB0b2tlbik7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCBnb3QgXCInICsgc2VnbWVudCArICdcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbmFsKSBjb250aW51ZTtcbiAgICAgIHZhciB0eXBlT2ZNZXNzYWdlID0gcmVwZWF0ID8gJ2FuIGFycmF5JyA6ICdhIHN0cmluZyc7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlICcgKyB0eXBlT2ZNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcbn1cblxuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbjtcbi8qKlxuICogQ3JlYXRlIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIHNwZWMuXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goc3RyLCBvcHRpb25zKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHZhciByZSA9IHBhdGhUb1JlZ2V4cChzdHIsIGtleXMsIG9wdGlvbnMpO1xuICByZXR1cm4gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucyk7XG59XG5cbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbi8qKlxuICogQ3JlYXRlIGEgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgb3V0cHV0LlxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4cFRvRnVuY3Rpb24ocmUsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfYSA9IG9wdGlvbnMuZGVjb2RlLFxuICAgICAgZGVjb2RlID0gX2EgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH0gOiBfYTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgIHZhciBtID0gcmUuZXhlYyhwYXRobmFtZSk7XG4gICAgaWYgKCFtKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHBhdGggPSBtWzBdLFxuICAgICAgICBpbmRleCA9IG0uaW5kZXg7XG4gICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIF9sb29wXzEoaSkge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICBpZiAobVtpXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgIHZhciBrZXkgPSBrZXlzW2kgLSAxXTtcblxuICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gJyonIHx8IGtleS5tb2RpZmllciA9PT0gJysnKSB7XG4gICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZSh2YWx1ZSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0cy5yZWdleHBUb0Z1bmN0aW9uID0gcmVnZXhwVG9GdW5jdGlvbjtcbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csICdcXFxcJDEnKTtcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZsYWdzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJztcbn1cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICovXG5cblxuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cykge1xuICBpZiAoIWtleXMpIHJldHVybiBwYXRoOyAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogJycsXG4gICAgICAgIHN1ZmZpeDogJycsXG4gICAgICAgIG1vZGlmaWVyOiAnJyxcbiAgICAgICAgcGF0dGVybjogJydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAocGF0aHMsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKS5zb3VyY2U7XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnZXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnZXhwKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9hID0gb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSxcbiAgICAgIF9iID0gb3B0aW9ucy5zdGFydCxcbiAgICAgIHN0YXJ0ID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYixcbiAgICAgIF9jID0gb3B0aW9ucy5lbmQsXG4gICAgICBlbmQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLFxuICAgICAgX2QgPSBvcHRpb25zLmVuY29kZSxcbiAgICAgIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4O1xuICB9IDogX2Q7XG4gIHZhciBlbmRzV2l0aCA9ICdbJyArIGVzY2FwZVN0cmluZyhvcHRpb25zLmVuZHNXaXRoIHx8ICcnKSArICddfCQnO1xuICB2YXIgZGVsaW1pdGVyID0gJ1snICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvIz8nKSArICddJztcbiAgdmFyIHJvdXRlID0gc3RhcnQgPyAnXicgOiAnJzsgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cblxuICBmb3IgKHZhciBfaSA9IDAsIHRva2Vuc18xID0gdG9rZW5zOyBfaSA8IHRva2Vuc18xLmxlbmd0aDsgX2krKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc18xW19pXTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgdmFyIHN1ZmZpeCA9IGVzY2FwZVN0cmluZyhlbmNvZGUodG9rZW4uc3VmZml4KSk7XG5cbiAgICAgIGlmICh0b2tlbi5wYXR0ZXJuKSB7XG4gICAgICAgIGlmIChrZXlzKSBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICAgIGlmIChwcmVmaXggfHwgc3VmZml4KSB7XG4gICAgICAgICAgaWYgKHRva2VuLm1vZGlmaWVyID09PSAnKycgfHwgdG9rZW4ubW9kaWZpZXIgPT09ICcqJykge1xuICAgICAgICAgICAgdmFyIG1vZCA9IHRva2VuLm1vZGlmaWVyID09PSAnKicgPyAnPycgOiAnJztcbiAgICAgICAgICAgIHJvdXRlICs9ICcoPzonICsgcHJlZml4ICsgJygoPzonICsgdG9rZW4ucGF0dGVybiArICcpKD86JyArIHN1ZmZpeCArIHByZWZpeCArICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpKSopJyArIHN1ZmZpeCArICcpJyArIG1vZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm91dGUgKz0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyB0b2tlbi5wYXR0ZXJuICsgJyknICsgc3VmZml4ICsgJyknICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlICs9ICcoJyArIHRva2VuLnBhdHRlcm4gKyAnKScgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm91dGUgKz0gJyg/OicgKyBwcmVmaXggKyBzdWZmaXggKyAnKScgKyB0b2tlbi5tb2RpZmllcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgaWYgKCFzdHJpY3QpIHJvdXRlICs9IGRlbGltaXRlciArICc/JztcbiAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/ICckJyA6ICcoPz0nICsgZW5kc1dpdGggKyAnKSc7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVuZFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0eXBlb2YgZW5kVG9rZW4gPT09ICdzdHJpbmcnID8gZGVsaW1pdGVyLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTEgOiAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBlbmRUb2tlbiA9PT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgIHJvdXRlICs9ICcoPzonICsgZGVsaW1pdGVyICsgJyg/PScgKyBlbmRzV2l0aCArICcpKT8nO1xuICAgIH1cblxuICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgIHJvdXRlICs9ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wnICsgZW5kc1dpdGggKyAnKSc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKTtcbn1cblxuZXhwb3J0cy50b2tlbnNUb1JlZ2V4cCA9IHRva2Vuc1RvUmVnZXhwO1xuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICovXG5cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwga2V5cyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnBhdGhUb1JlZ2V4cCA9IHBhdGhUb1JlZ2V4cDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@umijs/route-utils/es/path-to-regexp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@umijs/route-utils/es/sha265.js":
/*!******************************************************!*\
  !*** ./node_modules/@umijs/route-utils/es/sha265.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* eslint-disable no-redeclare */\n\n/* eslint-disable no-multi-assign */\n\n/* eslint-disable no-param-reassign */\n\n/* eslint-disable no-return-assign */\n\n/* eslint-disable no-new-wrappers */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n/* eslint-disable no-var */\n\n/* eslint-disable no-plusplus */\n\n/* eslint-disable prefer-destructuring */\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/* eslint-disable block-scoped-var */\n\n/* eslint-disable vars-on-top */\n\n/* eslint-disable no-bitwise */\n\n/* eslint-disable no-cond-assign */\n\n/*\n * A JavaScript implementation of the SHA256 hash function.\n *\n * FILE:\tsha256.js\n * VERSION:\t0.8\n * AUTHOR:\tChristoph Bichlmeier <informatik@zombiearena.de>\n *\n * NOTE: This version is not tested thoroughly!\n *\n * Copyright (c) 2003, Christoph Bichlmeier\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holder nor the names of contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * ======================================================================\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* SHA256 logical functions */\nfunction rotateRight(n, x) {\n  return x >>> n | x << 32 - n;\n}\n\nfunction choice(x, y, z) {\n  return x & y ^ ~x & z;\n}\n\nfunction majority(x, y, z) {\n  return x & y ^ x & z ^ y & z;\n}\n\nfunction sha256_Sigma0(x) {\n  return rotateRight(2, x) ^ rotateRight(13, x) ^ rotateRight(22, x);\n}\n\nfunction sha256_Sigma1(x) {\n  return rotateRight(6, x) ^ rotateRight(11, x) ^ rotateRight(25, x);\n}\n\nfunction sha256_sigma0(x) {\n  return rotateRight(7, x) ^ rotateRight(18, x) ^ x >>> 3;\n}\n\nfunction sha256_sigma1(x) {\n  return rotateRight(17, x) ^ rotateRight(19, x) ^ x >>> 10;\n}\n\nfunction sha256_expand(W, j) {\n  return W[j & 0x0f] += sha256_sigma1(W[j + 14 & 0x0f]) + W[j + 9 & 0x0f] + sha256_sigma0(W[j + 1 & 0x0f]);\n}\n/* Hash constant words K: */\n\n\nvar K256 = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n/* global arrays */\n\nvar ihash;\nvar count;\nvar buffer;\nvar sha256_hex_digits = '0123456789abcdef';\n/* Add 32-bit integers with 16-bit operations (bug in some JS-interpreters:\noverflow) */\n\nfunction safe_add(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/* Initialise the SHA256 computation */\n\n\nfunction sha256_init() {\n  ihash = new Array(8);\n  count = new Array(2);\n  buffer = new Array(64);\n  count[0] = count[1] = 0;\n  ihash[0] = 0x6a09e667;\n  ihash[1] = 0xbb67ae85;\n  ihash[2] = 0x3c6ef372;\n  ihash[3] = 0xa54ff53a;\n  ihash[4] = 0x510e527f;\n  ihash[5] = 0x9b05688c;\n  ihash[6] = 0x1f83d9ab;\n  ihash[7] = 0x5be0cd19;\n}\n/* Transform a 512-bit message block */\n\n\nfunction sha256_transform() {\n  var a;\n  var b;\n  var c;\n  var d;\n  var e;\n  var f;\n  var g;\n  var h;\n  var T1;\n  var T2;\n  var W = new Array(16);\n  /* Initialize registers with the previous intermediate value */\n\n  a = ihash[0];\n  b = ihash[1];\n  c = ihash[2];\n  d = ihash[3];\n  e = ihash[4];\n  f = ihash[5];\n  g = ihash[6];\n  h = ihash[7];\n  /* make 32-bit words */\n\n  for (var i = 0; i < 16; i++) {\n    W[i] = buffer[(i << 2) + 3] | buffer[(i << 2) + 2] << 8 | buffer[(i << 2) + 1] << 16 | buffer[i << 2] << 24;\n  }\n\n  for (var j = 0; j < 64; j++) {\n    T1 = h + sha256_Sigma1(e) + choice(e, f, g) + K256[j];\n    if (j < 16) T1 += W[j];else T1 += sha256_expand(W, j);\n    T2 = sha256_Sigma0(a) + majority(a, b, c);\n    h = g;\n    g = f;\n    f = e;\n    e = safe_add(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = safe_add(T1, T2);\n  }\n  /* Compute the current intermediate hash value */\n\n\n  ihash[0] += a;\n  ihash[1] += b;\n  ihash[2] += c;\n  ihash[3] += d;\n  ihash[4] += e;\n  ihash[5] += f;\n  ihash[6] += g;\n  ihash[7] += h;\n}\n/* Read the next chunk of data and update the SHA256 computation */\n\n\nfunction sha256_update(data, inputLen) {\n  var i;\n  var index;\n  var curpos = 0;\n  /* Compute number of bytes mod 64 */\n\n  index = count[0] >> 3 & 0x3f;\n  var remainder = inputLen & 0x3f;\n  /* Update number of bits */\n\n  if ((count[0] += inputLen << 3) < inputLen << 3) count[1]++;\n  count[1] += inputLen >> 29;\n  /* Transform as many times as possible */\n\n  for (i = 0; i + 63 < inputLen; i += 64) {\n    for (var j = index; j < 64; j++) {\n      buffer[j] = data.charCodeAt(curpos++);\n    }\n\n    sha256_transform();\n    index = 0;\n  }\n  /* Buffer remaining input */\n\n\n  for (var _j = 0; _j < remainder; _j++) {\n    buffer[_j] = data.charCodeAt(curpos++);\n  }\n}\n/* Finish the computation by operations such as padding */\n\n\nfunction sha256_final() {\n  var index = count[0] >> 3 & 0x3f;\n  buffer[index++] = 0x80;\n\n  if (index <= 56) {\n    for (var i = index; i < 56; i++) {\n      buffer[i] = 0;\n    }\n  } else {\n    for (var _i = index; _i < 64; _i++) {\n      buffer[_i] = 0;\n    }\n\n    sha256_transform();\n\n    for (var _i2 = 0; _i2 < 56; _i2++) {\n      buffer[_i2] = 0;\n    }\n  }\n\n  buffer[56] = count[1] >>> 24 & 0xff;\n  buffer[57] = count[1] >>> 16 & 0xff;\n  buffer[58] = count[1] >>> 8 & 0xff;\n  buffer[59] = count[1] & 0xff;\n  buffer[60] = count[0] >>> 24 & 0xff;\n  buffer[61] = count[0] >>> 16 & 0xff;\n  buffer[62] = count[0] >>> 8 & 0xff;\n  buffer[63] = count[0] & 0xff;\n  sha256_transform();\n}\n/* Split the internal hash values into an array of bytes */\n\n\nfunction sha256_encode_bytes() {\n  var j = 0;\n  var output = new Array(32);\n\n  for (var i = 0; i < 8; i++) {\n    output[j++] = ihash[i] >>> 24 & 0xff;\n    output[j++] = ihash[i] >>> 16 & 0xff;\n    output[j++] = ihash[i] >>> 8 & 0xff;\n    output[j++] = ihash[i] & 0xff;\n  }\n\n  return output;\n}\n/* Get the internal hash as a hex string */\n\n\nfunction sha256_encode_hex() {\n  var output = new String();\n\n  for (var i = 0; i < 8; i++) {\n    for (var j = 28; j >= 0; j -= 4) {\n      output += sha256_hex_digits.charAt(ihash[i] >>> j & 0x0f);\n    }\n  }\n\n  return output;\n}\n/* Main function: returns a hex string representing the SHA256 value of the\ngiven data */\n\n\nfunction digest(data) {\n  sha256_init();\n  sha256_update(data, data.length);\n  sha256_final();\n  return sha256_encode_hex();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (digest);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3JvdXRlLXV0aWxzL2VzL3NoYTI2NS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBbUI7QUFDakMsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLElBQUk7QUFDSix5QkFBeUIsU0FBUztBQUNsQztBQUNBOztBQUVBOztBQUVBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekIscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsTUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL2xldHR5Y29kZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdW1panMvcm91dGUtdXRpbHMvZXMvc2hhMjY1LmpzP2Q0YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcmVkZWNsYXJlICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLWFzc2lnbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXR1cm4tYXNzaWduICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy13cmFwcGVycyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nICovXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHZhcnMtb24tdG9wICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuLypcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgU0hBMjU2IGhhc2ggZnVuY3Rpb24uXG4gKlxuICogRklMRTpcdHNoYTI1Ni5qc1xuICogVkVSU0lPTjpcdDAuOFxuICogQVVUSE9SOlx0Q2hyaXN0b3BoIEJpY2hsbWVpZXIgPGluZm9ybWF0aWtAem9tYmllYXJlbmEuZGU+XG4gKlxuICogTk9URTogVGhpcyB2ZXJzaW9uIGlzIG5vdCB0ZXN0ZWQgdGhvcm91Z2hseSFcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDMsIENocmlzdG9waCBCaWNobG1laWVyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGNvbnRyaWJ1dG9yc1xuICogICAgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4gKiAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQVVUSE9SUyAnJ0FTIElTJycgQU5EIEFOWSBFWFBSRVNTXG4gKiBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPTlRSSUJVVE9SUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSxcbiAqIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxuLyogU0hBMjU2IGxvZ2ljYWwgZnVuY3Rpb25zICovXG5mdW5jdGlvbiByb3RhdGVSaWdodChuLCB4KSB7XG4gIHJldHVybiB4ID4+PiBuIHwgeCA8PCAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIGNob2ljZSh4LCB5LCB6KSB7XG4gIHJldHVybiB4ICYgeSBeIH54ICYgejtcbn1cblxuZnVuY3Rpb24gbWFqb3JpdHkoeCwgeSwgeikge1xuICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xufVxuXG5mdW5jdGlvbiBzaGEyNTZfU2lnbWEwKHgpIHtcbiAgcmV0dXJuIHJvdGF0ZVJpZ2h0KDIsIHgpIF4gcm90YXRlUmlnaHQoMTMsIHgpIF4gcm90YXRlUmlnaHQoMjIsIHgpO1xufVxuXG5mdW5jdGlvbiBzaGEyNTZfU2lnbWExKHgpIHtcbiAgcmV0dXJuIHJvdGF0ZVJpZ2h0KDYsIHgpIF4gcm90YXRlUmlnaHQoMTEsIHgpIF4gcm90YXRlUmlnaHQoMjUsIHgpO1xufVxuXG5mdW5jdGlvbiBzaGEyNTZfc2lnbWEwKHgpIHtcbiAgcmV0dXJuIHJvdGF0ZVJpZ2h0KDcsIHgpIF4gcm90YXRlUmlnaHQoMTgsIHgpIF4geCA+Pj4gMztcbn1cblxuZnVuY3Rpb24gc2hhMjU2X3NpZ21hMSh4KSB7XG4gIHJldHVybiByb3RhdGVSaWdodCgxNywgeCkgXiByb3RhdGVSaWdodCgxOSwgeCkgXiB4ID4+PiAxMDtcbn1cblxuZnVuY3Rpb24gc2hhMjU2X2V4cGFuZChXLCBqKSB7XG4gIHJldHVybiBXW2ogJiAweDBmXSArPSBzaGEyNTZfc2lnbWExKFdbaiArIDE0ICYgMHgwZl0pICsgV1tqICsgOSAmIDB4MGZdICsgc2hhMjU2X3NpZ21hMChXW2ogKyAxICYgMHgwZl0pO1xufVxuLyogSGFzaCBjb25zdGFudCB3b3JkcyBLOiAqL1xuXG5cbnZhciBLMjU2ID0gWzB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJdO1xuLyogZ2xvYmFsIGFycmF5cyAqL1xuXG52YXIgaWhhc2g7XG52YXIgY291bnQ7XG52YXIgYnVmZmVyO1xudmFyIHNoYTI1Nl9oZXhfZGlnaXRzID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuLyogQWRkIDMyLWJpdCBpbnRlZ2VycyB3aXRoIDE2LWJpdCBvcGVyYXRpb25zIChidWcgaW4gc29tZSBKUy1pbnRlcnByZXRlcnM6XG5vdmVyZmxvdykgKi9cblxuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKiBJbml0aWFsaXNlIHRoZSBTSEEyNTYgY29tcHV0YXRpb24gKi9cblxuXG5mdW5jdGlvbiBzaGEyNTZfaW5pdCgpIHtcbiAgaWhhc2ggPSBuZXcgQXJyYXkoOCk7XG4gIGNvdW50ID0gbmV3IEFycmF5KDIpO1xuICBidWZmZXIgPSBuZXcgQXJyYXkoNjQpO1xuICBjb3VudFswXSA9IGNvdW50WzFdID0gMDtcbiAgaWhhc2hbMF0gPSAweDZhMDllNjY3O1xuICBpaGFzaFsxXSA9IDB4YmI2N2FlODU7XG4gIGloYXNoWzJdID0gMHgzYzZlZjM3MjtcbiAgaWhhc2hbM10gPSAweGE1NGZmNTNhO1xuICBpaGFzaFs0XSA9IDB4NTEwZTUyN2Y7XG4gIGloYXNoWzVdID0gMHg5YjA1Njg4YztcbiAgaWhhc2hbNl0gPSAweDFmODNkOWFiO1xuICBpaGFzaFs3XSA9IDB4NWJlMGNkMTk7XG59XG4vKiBUcmFuc2Zvcm0gYSA1MTItYml0IG1lc3NhZ2UgYmxvY2sgKi9cblxuXG5mdW5jdGlvbiBzaGEyNTZfdHJhbnNmb3JtKCkge1xuICB2YXIgYTtcbiAgdmFyIGI7XG4gIHZhciBjO1xuICB2YXIgZDtcbiAgdmFyIGU7XG4gIHZhciBmO1xuICB2YXIgZztcbiAgdmFyIGg7XG4gIHZhciBUMTtcbiAgdmFyIFQyO1xuICB2YXIgVyA9IG5ldyBBcnJheSgxNik7XG4gIC8qIEluaXRpYWxpemUgcmVnaXN0ZXJzIHdpdGggdGhlIHByZXZpb3VzIGludGVybWVkaWF0ZSB2YWx1ZSAqL1xuXG4gIGEgPSBpaGFzaFswXTtcbiAgYiA9IGloYXNoWzFdO1xuICBjID0gaWhhc2hbMl07XG4gIGQgPSBpaGFzaFszXTtcbiAgZSA9IGloYXNoWzRdO1xuICBmID0gaWhhc2hbNV07XG4gIGcgPSBpaGFzaFs2XTtcbiAgaCA9IGloYXNoWzddO1xuICAvKiBtYWtlIDMyLWJpdCB3b3JkcyAqL1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIFdbaV0gPSBidWZmZXJbKGkgPDwgMikgKyAzXSB8IGJ1ZmZlclsoaSA8PCAyKSArIDJdIDw8IDggfCBidWZmZXJbKGkgPDwgMikgKyAxXSA8PCAxNiB8IGJ1ZmZlcltpIDw8IDJdIDw8IDI0O1xuICB9XG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA2NDsgaisrKSB7XG4gICAgVDEgPSBoICsgc2hhMjU2X1NpZ21hMShlKSArIGNob2ljZShlLCBmLCBnKSArIEsyNTZbal07XG4gICAgaWYgKGogPCAxNikgVDEgKz0gV1tqXTtlbHNlIFQxICs9IHNoYTI1Nl9leHBhbmQoVywgaik7XG4gICAgVDIgPSBzaGEyNTZfU2lnbWEwKGEpICsgbWFqb3JpdHkoYSwgYiwgYyk7XG4gICAgaCA9IGc7XG4gICAgZyA9IGY7XG4gICAgZiA9IGU7XG4gICAgZSA9IHNhZmVfYWRkKGQsIFQxKTtcbiAgICBkID0gYztcbiAgICBjID0gYjtcbiAgICBiID0gYTtcbiAgICBhID0gc2FmZV9hZGQoVDEsIFQyKTtcbiAgfVxuICAvKiBDb21wdXRlIHRoZSBjdXJyZW50IGludGVybWVkaWF0ZSBoYXNoIHZhbHVlICovXG5cblxuICBpaGFzaFswXSArPSBhO1xuICBpaGFzaFsxXSArPSBiO1xuICBpaGFzaFsyXSArPSBjO1xuICBpaGFzaFszXSArPSBkO1xuICBpaGFzaFs0XSArPSBlO1xuICBpaGFzaFs1XSArPSBmO1xuICBpaGFzaFs2XSArPSBnO1xuICBpaGFzaFs3XSArPSBoO1xufVxuLyogUmVhZCB0aGUgbmV4dCBjaHVuayBvZiBkYXRhIGFuZCB1cGRhdGUgdGhlIFNIQTI1NiBjb21wdXRhdGlvbiAqL1xuXG5cbmZ1bmN0aW9uIHNoYTI1Nl91cGRhdGUoZGF0YSwgaW5wdXRMZW4pIHtcbiAgdmFyIGk7XG4gIHZhciBpbmRleDtcbiAgdmFyIGN1cnBvcyA9IDA7XG4gIC8qIENvbXB1dGUgbnVtYmVyIG9mIGJ5dGVzIG1vZCA2NCAqL1xuXG4gIGluZGV4ID0gY291bnRbMF0gPj4gMyAmIDB4M2Y7XG4gIHZhciByZW1haW5kZXIgPSBpbnB1dExlbiAmIDB4M2Y7XG4gIC8qIFVwZGF0ZSBudW1iZXIgb2YgYml0cyAqL1xuXG4gIGlmICgoY291bnRbMF0gKz0gaW5wdXRMZW4gPDwgMykgPCBpbnB1dExlbiA8PCAzKSBjb3VudFsxXSsrO1xuICBjb3VudFsxXSArPSBpbnB1dExlbiA+PiAyOTtcbiAgLyogVHJhbnNmb3JtIGFzIG1hbnkgdGltZXMgYXMgcG9zc2libGUgKi9cblxuICBmb3IgKGkgPSAwOyBpICsgNjMgPCBpbnB1dExlbjsgaSArPSA2NCkge1xuICAgIGZvciAodmFyIGogPSBpbmRleDsgaiA8IDY0OyBqKyspIHtcbiAgICAgIGJ1ZmZlcltqXSA9IGRhdGEuY2hhckNvZGVBdChjdXJwb3MrKyk7XG4gICAgfVxuXG4gICAgc2hhMjU2X3RyYW5zZm9ybSgpO1xuICAgIGluZGV4ID0gMDtcbiAgfVxuICAvKiBCdWZmZXIgcmVtYWluaW5nIGlucHV0ICovXG5cblxuICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcmVtYWluZGVyOyBfaisrKSB7XG4gICAgYnVmZmVyW19qXSA9IGRhdGEuY2hhckNvZGVBdChjdXJwb3MrKyk7XG4gIH1cbn1cbi8qIEZpbmlzaCB0aGUgY29tcHV0YXRpb24gYnkgb3BlcmF0aW9ucyBzdWNoIGFzIHBhZGRpbmcgKi9cblxuXG5mdW5jdGlvbiBzaGEyNTZfZmluYWwoKSB7XG4gIHZhciBpbmRleCA9IGNvdW50WzBdID4+IDMgJiAweDNmO1xuICBidWZmZXJbaW5kZXgrK10gPSAweDgwO1xuXG4gIGlmIChpbmRleCA8PSA1Nikge1xuICAgIGZvciAodmFyIGkgPSBpbmRleDsgaSA8IDU2OyBpKyspIHtcbiAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9pID0gaW5kZXg7IF9pIDwgNjQ7IF9pKyspIHtcbiAgICAgIGJ1ZmZlcltfaV0gPSAwO1xuICAgIH1cblxuICAgIHNoYTI1Nl90cmFuc2Zvcm0oKTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IDU2OyBfaTIrKykge1xuICAgICAgYnVmZmVyW19pMl0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIGJ1ZmZlcls1Nl0gPSBjb3VudFsxXSA+Pj4gMjQgJiAweGZmO1xuICBidWZmZXJbNTddID0gY291bnRbMV0gPj4+IDE2ICYgMHhmZjtcbiAgYnVmZmVyWzU4XSA9IGNvdW50WzFdID4+PiA4ICYgMHhmZjtcbiAgYnVmZmVyWzU5XSA9IGNvdW50WzFdICYgMHhmZjtcbiAgYnVmZmVyWzYwXSA9IGNvdW50WzBdID4+PiAyNCAmIDB4ZmY7XG4gIGJ1ZmZlcls2MV0gPSBjb3VudFswXSA+Pj4gMTYgJiAweGZmO1xuICBidWZmZXJbNjJdID0gY291bnRbMF0gPj4+IDggJiAweGZmO1xuICBidWZmZXJbNjNdID0gY291bnRbMF0gJiAweGZmO1xuICBzaGEyNTZfdHJhbnNmb3JtKCk7XG59XG4vKiBTcGxpdCB0aGUgaW50ZXJuYWwgaGFzaCB2YWx1ZXMgaW50byBhbiBhcnJheSBvZiBieXRlcyAqL1xuXG5cbmZ1bmN0aW9uIHNoYTI1Nl9lbmNvZGVfYnl0ZXMoKSB7XG4gIHZhciBqID0gMDtcbiAgdmFyIG91dHB1dCA9IG5ldyBBcnJheSgzMik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBvdXRwdXRbaisrXSA9IGloYXNoW2ldID4+PiAyNCAmIDB4ZmY7XG4gICAgb3V0cHV0W2orK10gPSBpaGFzaFtpXSA+Pj4gMTYgJiAweGZmO1xuICAgIG91dHB1dFtqKytdID0gaWhhc2hbaV0gPj4+IDggJiAweGZmO1xuICAgIG91dHB1dFtqKytdID0gaWhhc2hbaV0gJiAweGZmO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qIEdldCB0aGUgaW50ZXJuYWwgaGFzaCBhcyBhIGhleCBzdHJpbmcgKi9cblxuXG5mdW5jdGlvbiBzaGEyNTZfZW5jb2RlX2hleCgpIHtcbiAgdmFyIG91dHB1dCA9IG5ldyBTdHJpbmcoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAyODsgaiA+PSAwOyBqIC09IDQpIHtcbiAgICAgIG91dHB1dCArPSBzaGEyNTZfaGV4X2RpZ2l0cy5jaGFyQXQoaWhhc2hbaV0gPj4+IGogJiAweDBmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyogTWFpbiBmdW5jdGlvbjogcmV0dXJucyBhIGhleCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBTSEEyNTYgdmFsdWUgb2YgdGhlXG5naXZlbiBkYXRhICovXG5cblxuZnVuY3Rpb24gZGlnZXN0KGRhdGEpIHtcbiAgc2hhMjU2X2luaXQoKTtcbiAgc2hhMjU2X3VwZGF0ZShkYXRhLCBkYXRhLmxlbmd0aCk7XG4gIHNoYTI1Nl9maW5hbCgpO1xuICByZXR1cm4gc2hhMjU2X2VuY29kZV9oZXgoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGlnZXN0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@umijs/route-utils/es/sha265.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@umijs/route-utils/es/transformRoute/transformRoute.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@umijs/route-utils/es/transformRoute/transformRoute.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   childrenPropsName: () => (/* binding */ childrenPropsName),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getKeyByPath: () => (/* binding */ getKeyByPath),\n/* harmony export */   isUrl: () => (/* binding */ isUrl),\n/* harmony export */   stripQueryStringAndHashFromPath: () => (/* binding */ stripQueryStringAndHashFromPath)\n/* harmony export */ });\n/* harmony import */ var _path_to_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../path-to-regexp */ \"(ssr)/./node_modules/@umijs/route-utils/es/path-to-regexp.js\");\n/* harmony import */ var _sha265__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../sha265 */ \"(ssr)/./node_modules/@umijs/route-utils/es/sha265.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nvar _excluded = [\"pro_layout_parentKeys\", \"children\", \"icon\", \"flatMenu\", \"indexRoute\", \"routes\"];\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//@ts-ignore\n\n\nvar childrenPropsName = 'routes';\nfunction stripQueryStringAndHashFromPath(url) {\n  return url.split('?')[0].split('#')[0];\n}\nvar isUrl = function isUrl(path) {\n  if (!path.startsWith('http')) {\n    return false;\n  }\n\n  try {\n    var url = new URL(path);\n    return !!url;\n  } catch (error) {\n    return false;\n  }\n};\nvar getKeyByPath = function getKeyByPath(item) {\n  var path = item.path;\n\n  if (!path || path === '/') {\n    // 如果还是没有，用对象的hash 生成一个\n    try {\n      return \"/\".concat((0,_sha265__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(JSON.stringify(item)));\n    } catch (error) {// dom some thing\n    }\n  }\n\n  return path ? stripQueryStringAndHashFromPath(path) : path;\n};\n/**\n * 获取locale，增加了一个功能，如果 locale = false，将不使用国际化\n * @param item\n * @param parentName\n */\n\nvar getItemLocaleName = function getItemLocaleName(item, parentName) {\n  var name = item.name,\n      locale = item.locale; // 如果配置了 locale 并且 locale 为 false或 \"\"\n\n  if ('locale' in item && locale === false || !name) {\n    return false;\n  }\n\n  return item.locale || \"\".concat(parentName, \".\").concat(name);\n};\n/**\n * 如果不是 / 开头的和父节点做一下合并\n * 如果是 / 开头的不作任何处理\n * 如果是 url 也直接返回\n * @param path\n * @param parentPath\n */\n\n\nvar mergePath = function mergePath() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/';\n\n  if (path.endsWith('/*')) {\n    return path.replace('/*', '/');\n  }\n\n  if ((path || parentPath).startsWith('/')) {\n    return path;\n  }\n\n  if (isUrl(path)) {\n    return path;\n  }\n\n  return \"/\".concat(parentPath, \"/\").concat(path).replace(/\\/\\//g, '/').replace(/\\/\\//g, '/');\n}; // bigfish 的兼容准话\n\n\nvar bigfishCompatibleConversions = function bigfishCompatibleConversions(route, props) {\n  var _route$menu = route.menu,\n      menu = _route$menu === void 0 ? {} : _route$menu,\n      indexRoute = route.indexRoute,\n      _route$path = route.path,\n      path = _route$path === void 0 ? '' : _route$path;\n  var routerChildren = route.children || [];\n  var _menu$name = menu.name,\n      name = _menu$name === void 0 ? route.name : _menu$name,\n      _menu$icon = menu.icon,\n      icon = _menu$icon === void 0 ? route.icon : _menu$icon,\n      _menu$hideChildren = menu.hideChildren,\n      hideChildren = _menu$hideChildren === void 0 ? route.hideChildren : _menu$hideChildren,\n      _menu$flatMenu = menu.flatMenu,\n      flatMenu = _menu$flatMenu === void 0 ? route.flatMenu : _menu$flatMenu; // 兼容平铺式写法\n  // 拼接 childrenRoutes, 处理存在 indexRoute 时的逻辑\n\n  var childrenList = indexRoute && // 如果只有 redirect,不用处理的\n  Object.keys(indexRoute).join(',') !== 'redirect' ? [_objectSpread({\n    path: path,\n    menu: menu\n  }, indexRoute)].concat(routerChildren || []) : routerChildren; // 拼接返回的 menu 数据\n\n  var result = _objectSpread({}, route);\n\n  if (name) {\n    result.name = name;\n  }\n\n  if (icon) {\n    result.icon = icon;\n  }\n\n  if (childrenList && childrenList.length) {\n    /** 在菜单中隐藏子项 */\n    if (hideChildren) {\n      delete result.children;\n      return result;\n    } // 需要重新进行一次\n\n\n    var finalChildren = formatter(_objectSpread(_objectSpread({}, props), {}, {\n      data: childrenList\n    }), route);\n    /** 在菜单中只隐藏此项，子项往上提，仍旧展示 */\n\n    if (flatMenu) {\n      return finalChildren;\n    }\n\n    delete result[childrenPropsName];\n  }\n\n  return result;\n};\n\nvar notNullArray = function notNullArray(value) {\n  return Array.isArray(value) && value.length > 0;\n};\n/**\n *\n * @param props\n * @param parent\n */\n\n\nfunction formatter(props) {\n  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    path: '/'\n  };\n  var data = props.data,\n      formatMessage = props.formatMessage,\n      parentName = props.parentName,\n      menuLocale = props.locale;\n\n  if (!data || !Array.isArray(data)) {\n    return [];\n  }\n\n  return data.filter(function (item) {\n    if (!item) return false;\n    if (notNullArray(item.children)) return true;\n    if (item.path) return true;\n    if (item.originPath) return true;\n    if (item.layout) return true; // 重定向\n\n    if (item.redirect) return false;\n    if (item.unaccessible) return false;\n    return false;\n  }).filter(function (item) {\n    var _item$menu, _item$menu2;\n\n    if ((item === null || item === void 0 ? void 0 : (_item$menu = item.menu) === null || _item$menu === void 0 ? void 0 : _item$menu.name) || (item === null || item === void 0 ? void 0 : item.flatMenu) || (item === null || item === void 0 ? void 0 : (_item$menu2 = item.menu) === null || _item$menu2 === void 0 ? void 0 : _item$menu2.flatMenu)) {\n      return true;\n    } // 显示指定在 menu 中隐藏该项\n    // layout 插件的功能，其实不应该存在的\n\n\n    if (item.menu === false) {\n      return false;\n    }\n\n    return true;\n  }).map(function (finallyItem) {\n    var item = _objectSpread(_objectSpread({}, finallyItem), {}, {\n      path: finallyItem.path || finallyItem.originPath\n    });\n\n    if (!item.children && item[childrenPropsName]) {\n      item.children = item[childrenPropsName];\n      delete item[childrenPropsName];\n    } // 是否没有权限查看\n    // 这样就不会显示，是一个兼容性的方式\n\n\n    if (item.unaccessible) {\n      // eslint-disable-next-line no-param-reassign\n      delete item.name;\n    }\n\n    if (item.path === '*') {\n      item.path = '.';\n    }\n\n    if (item.path === '/*') {\n      item.path = '.';\n    }\n\n    if (!item.path && item.originPath) {\n      item.path = item.originPath;\n    }\n\n    return item;\n  }).map(function () {\n    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      path: '/'\n    };\n    var routerChildren = item.children || item[childrenPropsName] || [];\n    var path = mergePath(item.path, parent ? parent.path : '/');\n    var name = item.name;\n    var locale = getItemLocaleName(item, parentName || 'menu'); // if enableMenuLocale use item.name,\n    // close menu international\n\n    var localeName = locale !== false && menuLocale !== false && formatMessage && locale ? formatMessage({\n      id: locale,\n      defaultMessage: name\n    }) : name;\n\n    var _parent$pro_layout_pa = parent.pro_layout_parentKeys,\n        pro_layout_parentKeys = _parent$pro_layout_pa === void 0 ? [] : _parent$pro_layout_pa,\n        children = parent.children,\n        icon = parent.icon,\n        flatMenu = parent.flatMenu,\n        indexRoute = parent.indexRoute,\n        routes = parent.routes,\n        restParent = _objectWithoutProperties(parent, _excluded);\n\n    var item_pro_layout_parentKeys = new Set([].concat(_toConsumableArray(pro_layout_parentKeys), _toConsumableArray(item.parentKeys || [])));\n\n    if (parent.key) {\n      item_pro_layout_parentKeys.add(parent.key);\n    }\n\n    var finallyItem = _objectSpread(_objectSpread(_objectSpread({}, restParent), {}, {\n      menu: undefined\n    }, item), {}, {\n      path: path,\n      locale: locale,\n      key: item.key || getKeyByPath(_objectSpread(_objectSpread({}, item), {}, {\n        path: path\n      })),\n      pro_layout_parentKeys: Array.from(item_pro_layout_parentKeys).filter(function (key) {\n        return key && key !== '/';\n      })\n    });\n\n    if (localeName) {\n      finallyItem.name = localeName;\n    } else {\n      delete finallyItem.name;\n    }\n\n    if (finallyItem.menu === undefined) {\n      delete finallyItem.menu;\n    }\n\n    if (notNullArray(routerChildren)) {\n      var formatterChildren = formatter(_objectSpread(_objectSpread({}, props), {}, {\n        data: routerChildren,\n        parentName: locale || ''\n      }), finallyItem);\n\n      if (notNullArray(formatterChildren)) {\n        finallyItem.children = formatterChildren;\n      }\n    }\n\n    return bigfishCompatibleConversions(finallyItem, props);\n  }).flat(1);\n}\n/**\n * 删除 hideInMenu 和 item.name 不存在的\n */\n\n\nvar defaultFilterMenuData = function defaultFilterMenuData() {\n  var menuData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return menuData.filter(function (item) {\n    return item && (item.name || notNullArray(item.children)) && !item.hideInMenu && !item.redirect;\n  }).map(function (item) {\n    var newItem = _objectSpread({}, item);\n\n    var routerChildren = newItem.children || item[childrenPropsName] || [];\n    delete newItem[childrenPropsName];\n\n    if (notNullArray(routerChildren) && !newItem.hideChildrenInMenu && routerChildren.some(function (child) {\n      return child && !!child.name;\n    })) {\n      var newChildren = defaultFilterMenuData(routerChildren);\n      if (newChildren.length) return _objectSpread(_objectSpread({}, newItem), {}, {\n        children: newChildren\n      });\n    }\n\n    return _objectSpread({}, item);\n  }).filter(function (item) {\n    return item;\n  });\n};\n/**\n * support pathToRegexp get string\n */\n\n\nvar RouteListMap = /*#__PURE__*/function (_Map) {\n  _inherits(RouteListMap, _Map);\n\n  var _super = _createSuper(RouteListMap);\n\n  function RouteListMap() {\n    _classCallCheck(this, RouteListMap);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(RouteListMap, [{\n    key: \"get\",\n    value: function get(pathname) {\n      var routeValue;\n\n      try {\n        // eslint-disable-next-line no-restricted-syntax\n        var _iterator = _createForOfIteratorHelper(this.entries()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                key = _step$value[0],\n                value = _step$value[1];\n\n            var path = stripQueryStringAndHashFromPath(key);\n\n            if (!isUrl(key) && (0,_path_to_regexp__WEBPACK_IMPORTED_MODULE_0__.pathToRegexp)(path, []).test(pathname)) {\n              routeValue = value;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } catch (error) {\n        routeValue = undefined;\n      }\n\n      return routeValue;\n    }\n  }]);\n\n  return RouteListMap;\n}( /*#__PURE__*/_wrapNativeSuper(Map));\n/**\n * 获取面包屑映射\n * @param MenuDataItem[] menuData 菜单配置\n */\n\n\nvar getBreadcrumbNameMap = function getBreadcrumbNameMap(menuData) {\n  // Map is used to ensure the order of keys\n  var routerMap = new RouteListMap();\n\n  var flattenMenuData = function flattenMenuData(data, parent) {\n    data.forEach(function (menuItem) {\n      var routerChildren = menuItem.children || menuItem[childrenPropsName] || [];\n\n      if (notNullArray(routerChildren)) {\n        flattenMenuData(routerChildren, menuItem);\n      } // Reduce memory usage\n\n\n      var path = mergePath(menuItem.path, parent ? parent.path : '/');\n      routerMap.set(stripQueryStringAndHashFromPath(path), menuItem);\n    });\n  };\n\n  flattenMenuData(menuData);\n  return routerMap;\n};\n\nvar clearChildren = function clearChildren() {\n  var menuData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return menuData.map(function (item) {\n    var routerChildren = item.children || item[childrenPropsName];\n\n    if (notNullArray(routerChildren)) {\n      var newChildren = clearChildren(routerChildren);\n      if (newChildren.length) return _objectSpread({}, item);\n    }\n\n    var finallyItem = _objectSpread({}, item);\n\n    delete finallyItem[childrenPropsName];\n    delete finallyItem.children;\n    return finallyItem;\n  }).filter(function (item) {\n    return item;\n  });\n};\n/**\n * @param routeList 路由配置\n * @param locale 是否使用国际化\n * @param formatMessage 国际化的程序\n * @param ignoreFilter 是否筛选掉不展示的 menuItem 项，plugin-layout需要所有项目来计算布局样式\n * @returns { breadcrumb, menuData}\n */\n\n\nvar transformRoute = function transformRoute(routeList, locale, formatMessage, ignoreFilter) {\n  var originalMenuData = formatter({\n    data: routeList,\n    formatMessage: formatMessage,\n    locale: locale\n  });\n  var menuData = ignoreFilter ? clearChildren(originalMenuData) : defaultFilterMenuData(originalMenuData); // Map type used for internal logic\n\n  var breadcrumb = getBreadcrumbNameMap(originalMenuData);\n  return {\n    breadcrumb: breadcrumb,\n    menuData: menuData\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (transformRoute);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3JvdXRlLXV0aWxzL2VzL3RyYW5zZm9ybVJvdXRlL3RyYW5zZm9ybVJvdXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx3QkFBd0IsMkJBQTJCLHNHQUFzRyxxQkFBcUIsbUJBQW1CLDhIQUE4SDs7QUFFL1Q7O0FBRUEsa0NBQWtDOztBQUVsQyw4QkFBOEI7O0FBRTlCLHlDQUF5QywwR0FBMEcsd0JBQXdCLGVBQWUsZUFBZSxnQkFBZ0IsWUFBWSxNQUFNLHdCQUF3QiwrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSxtREFBbUQsVUFBVSxzQkFBc0I7O0FBRW5mLGdDQUFnQzs7QUFFaEMseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0IsdUJBQXVCLFlBQVksWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0sMkRBQTJELFVBQVU7O0FBRXo4QixrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4USwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7O0FBRTVZLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlLDRCQUE0QixtRkFBbUY7O0FBRTFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4SixtQ0FBbUMsZ0VBQWdFLHNEQUFzRCwrREFBK0QsbUNBQW1DLDZFQUE2RSxxQ0FBcUMsaURBQWlELDhCQUE4QixxQkFBcUIsMEVBQTBFLHFEQUFxRCxlQUFlLHlFQUF5RSxHQUFHLDJDQUEyQzs7QUFFdHRCLDJDQUEyQyxtQ0FBbUMseUNBQXlDLE9BQU8sd0RBQXdELGdCQUFnQix1QkFBdUIsa0RBQWtELGtDQUFrQyx1REFBdUQsc0JBQXNCOztBQUU5WCx1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULGlDQUFpQzs7QUFFakMsaUNBQWlDLDBHQUEwRyxpQkFBaUIsYUFBYTs7QUFFekssOEJBQThCLHVHQUF1RyxtREFBbUQ7O0FBRXhMLG1DQUFtQzs7QUFFbkMsZ0NBQWdDOztBQUVoQyxrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDs7QUFFN1Msa0NBQWtDOztBQUVsQyxtQ0FBbUM7O0FBRW5DLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxvQkFBb0I7O0FBRXpLLHNEQUFzRCwrQkFBK0IsOERBQThELFlBQVksb0NBQW9DLDZEQUE2RCxZQUFZLDZCQUE2QixPQUFPLDJCQUEyQiwwQ0FBMEMsd0VBQXdFLCtCQUErQjs7QUFFNWQsMkRBQTJELCtCQUErQixpQkFBaUIsc0NBQXNDLFlBQVksWUFBWSx1QkFBdUIsT0FBTyxxQkFBcUIsMENBQTBDLDZCQUE2Qjs7QUFFblMsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDZEQUE2RCxpRUFBaUUsc0NBQXNDOztBQUV2VSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCw2REFBNkQsNENBQTRDLG9LQUFvSyxtRkFBbUYsS0FBSzs7QUFFMWUsNENBQTRDLGtCQUFrQixrQ0FBa0Msb0VBQW9FLEtBQUssT0FBTyxvQkFBb0I7O0FBRXBNO0FBQ2lEO0FBQ2xCO0FBQ3hCO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1EQUFNO0FBQzlCLE1BQU0sZUFBZTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOERBQThEOztBQUVqRSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQSxLQUFLLFdBQVc7QUFDaEI7QUFDQTtBQUNBLGtFQUFrRSxXQUFXO0FBQzdFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFLFlBQVk7QUFDbEY7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsbUVBQW1FLGNBQWM7QUFDakY7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsMkJBQTJCO0FBQzNCLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0IsNkRBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyR0FBMkc7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGV0dHljb2RlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B1bWlqcy9yb3V0ZS11dGlscy9lcy90cmFuc2Zvcm1Sb3V0ZS90cmFuc2Zvcm1Sb3V0ZS5qcz9iMGQwIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxudmFyIF9leGNsdWRlZCA9IFtcInByb19sYXlvdXRfcGFyZW50S2V5c1wiLCBcImNoaWxkcmVuXCIsIFwiaWNvblwiLCBcImZsYXRNZW51XCIsIFwiaW5kZXhSb3V0ZVwiLCBcInJvdXRlc1wiXTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgdGhyb3cgX2UyOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UzKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMzsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiBmYWxzZSB9KTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkOyBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykgeyBpZiAoQ2xhc3MgPT09IG51bGwgfHwgIV9pc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzOyBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7IGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpOyBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTsgfSBmdW5jdGlvbiBXcmFwcGVyKCkgeyByZXR1cm4gX2NvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9IFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IFdyYXBwZXIsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IHJldHVybiBfc2V0UHJvdG90eXBlT2YoV3JhcHBlciwgQ2xhc3MpOyB9OyByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7IH1cblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHsgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0LmJpbmQoKTsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZUZ1bmN0aW9uKGZuKSB7IHJldHVybiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKGZuKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTsgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vL0B0cy1pZ25vcmVcbmltcG9ydCB7IHBhdGhUb1JlZ2V4cCB9IGZyb20gJy4uL3BhdGgtdG8tcmVnZXhwJztcbmltcG9ydCBzaGEyNjUgZnJvbSAnLi4vc2hhMjY1JztcbmV4cG9ydCB2YXIgY2hpbGRyZW5Qcm9wc05hbWUgPSAncm91dGVzJztcbmV4cG9ydCBmdW5jdGlvbiBzdHJpcFF1ZXJ5U3RyaW5nQW5kSGFzaEZyb21QYXRoKHVybCkge1xuICByZXR1cm4gdXJsLnNwbGl0KCc/JylbMF0uc3BsaXQoJyMnKVswXTtcbn1cbmV4cG9ydCB2YXIgaXNVcmwgPSBmdW5jdGlvbiBpc1VybChwYXRoKSB7XG4gIGlmICghcGF0aC5zdGFydHNXaXRoKCdodHRwJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciB1cmwgPSBuZXcgVVJMKHBhdGgpO1xuICAgIHJldHVybiAhIXVybDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5leHBvcnQgdmFyIGdldEtleUJ5UGF0aCA9IGZ1bmN0aW9uIGdldEtleUJ5UGF0aChpdGVtKSB7XG4gIHZhciBwYXRoID0gaXRlbS5wYXRoO1xuXG4gIGlmICghcGF0aCB8fCBwYXRoID09PSAnLycpIHtcbiAgICAvLyDlpoLmnpzov5jmmK/msqHmnInvvIznlKjlr7nosaHnmoRoYXNoIOeUn+aIkOS4gOS4qlxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gXCIvXCIuY29uY2F0KHNoYTI2NShKU09OLnN0cmluZ2lmeShpdGVtKSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gZG9tIHNvbWUgdGhpbmdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aCA/IHN0cmlwUXVlcnlTdHJpbmdBbmRIYXNoRnJvbVBhdGgocGF0aCkgOiBwYXRoO1xufTtcbi8qKlxuICog6I635Y+WbG9jYWxl77yM5aKe5Yqg5LqG5LiA5Liq5Yqf6IO977yM5aaC5p6cIGxvY2FsZSA9IGZhbHNl77yM5bCG5LiN5L2/55So5Zu96ZmF5YyWXG4gKiBAcGFyYW0gaXRlbVxuICogQHBhcmFtIHBhcmVudE5hbWVcbiAqL1xuXG52YXIgZ2V0SXRlbUxvY2FsZU5hbWUgPSBmdW5jdGlvbiBnZXRJdGVtTG9jYWxlTmFtZShpdGVtLCBwYXJlbnROYW1lKSB7XG4gIHZhciBuYW1lID0gaXRlbS5uYW1lLFxuICAgICAgbG9jYWxlID0gaXRlbS5sb2NhbGU7IC8vIOWmguaenOmFjee9ruS6hiBsb2NhbGUg5bm25LiUIGxvY2FsZSDkuLogZmFsc2XmiJYgXCJcIlxuXG4gIGlmICgnbG9jYWxlJyBpbiBpdGVtICYmIGxvY2FsZSA9PT0gZmFsc2UgfHwgIW5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXRlbS5sb2NhbGUgfHwgXCJcIi5jb25jYXQocGFyZW50TmFtZSwgXCIuXCIpLmNvbmNhdChuYW1lKTtcbn07XG4vKipcbiAqIOWmguaenOS4jeaYryAvIOW8gOWktOeahOWSjOeItuiKgueCueWBmuS4gOS4i+WQiOW5tlxuICog5aaC5p6c5pivIC8g5byA5aS055qE5LiN5L2c5Lu75L2V5aSE55CGXG4gKiDlpoLmnpzmmK8gdXJsIOS5n+ebtOaOpei/lOWbnlxuICogQHBhcmFtIHBhdGhcbiAqIEBwYXJhbSBwYXJlbnRQYXRoXG4gKi9cblxuXG52YXIgbWVyZ2VQYXRoID0gZnVuY3Rpb24gbWVyZ2VQYXRoKCkge1xuICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gIHZhciBwYXJlbnRQYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnLyc7XG5cbiAgaWYgKHBhdGguZW5kc1dpdGgoJy8qJykpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKCcvKicsICcvJyk7XG4gIH1cblxuICBpZiAoKHBhdGggfHwgcGFyZW50UGF0aCkuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICBpZiAoaXNVcmwocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIHJldHVybiBcIi9cIi5jb25jYXQocGFyZW50UGF0aCwgXCIvXCIpLmNvbmNhdChwYXRoKS5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKS5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKTtcbn07IC8vIGJpZ2Zpc2gg55qE5YW85a655YeG6K+dXG5cblxudmFyIGJpZ2Zpc2hDb21wYXRpYmxlQ29udmVyc2lvbnMgPSBmdW5jdGlvbiBiaWdmaXNoQ29tcGF0aWJsZUNvbnZlcnNpb25zKHJvdXRlLCBwcm9wcykge1xuICB2YXIgX3JvdXRlJG1lbnUgPSByb3V0ZS5tZW51LFxuICAgICAgbWVudSA9IF9yb3V0ZSRtZW51ID09PSB2b2lkIDAgPyB7fSA6IF9yb3V0ZSRtZW51LFxuICAgICAgaW5kZXhSb3V0ZSA9IHJvdXRlLmluZGV4Um91dGUsXG4gICAgICBfcm91dGUkcGF0aCA9IHJvdXRlLnBhdGgsXG4gICAgICBwYXRoID0gX3JvdXRlJHBhdGggPT09IHZvaWQgMCA/ICcnIDogX3JvdXRlJHBhdGg7XG4gIHZhciByb3V0ZXJDaGlsZHJlbiA9IHJvdXRlLmNoaWxkcmVuIHx8IFtdO1xuICB2YXIgX21lbnUkbmFtZSA9IG1lbnUubmFtZSxcbiAgICAgIG5hbWUgPSBfbWVudSRuYW1lID09PSB2b2lkIDAgPyByb3V0ZS5uYW1lIDogX21lbnUkbmFtZSxcbiAgICAgIF9tZW51JGljb24gPSBtZW51Lmljb24sXG4gICAgICBpY29uID0gX21lbnUkaWNvbiA9PT0gdm9pZCAwID8gcm91dGUuaWNvbiA6IF9tZW51JGljb24sXG4gICAgICBfbWVudSRoaWRlQ2hpbGRyZW4gPSBtZW51LmhpZGVDaGlsZHJlbixcbiAgICAgIGhpZGVDaGlsZHJlbiA9IF9tZW51JGhpZGVDaGlsZHJlbiA9PT0gdm9pZCAwID8gcm91dGUuaGlkZUNoaWxkcmVuIDogX21lbnUkaGlkZUNoaWxkcmVuLFxuICAgICAgX21lbnUkZmxhdE1lbnUgPSBtZW51LmZsYXRNZW51LFxuICAgICAgZmxhdE1lbnUgPSBfbWVudSRmbGF0TWVudSA9PT0gdm9pZCAwID8gcm91dGUuZmxhdE1lbnUgOiBfbWVudSRmbGF0TWVudTsgLy8g5YW85a655bmz6ZO65byP5YaZ5rOVXG4gIC8vIOaLvOaOpSBjaGlsZHJlblJvdXRlcywg5aSE55CG5a2Y5ZyoIGluZGV4Um91dGUg5pe255qE6YC76L6RXG5cbiAgdmFyIGNoaWxkcmVuTGlzdCA9IGluZGV4Um91dGUgJiYgLy8g5aaC5p6c5Y+q5pyJIHJlZGlyZWN0LOS4jeeUqOWkhOeQhueahFxuICBPYmplY3Qua2V5cyhpbmRleFJvdXRlKS5qb2luKCcsJykgIT09ICdyZWRpcmVjdCcgPyBbX29iamVjdFNwcmVhZCh7XG4gICAgcGF0aDogcGF0aCxcbiAgICBtZW51OiBtZW51XG4gIH0sIGluZGV4Um91dGUpXS5jb25jYXQocm91dGVyQ2hpbGRyZW4gfHwgW10pIDogcm91dGVyQ2hpbGRyZW47IC8vIOaLvOaOpei/lOWbnueahCBtZW51IOaVsOaNrlxuXG4gIHZhciByZXN1bHQgPSBfb2JqZWN0U3ByZWFkKHt9LCByb3V0ZSk7XG5cbiAgaWYgKG5hbWUpIHtcbiAgICByZXN1bHQubmFtZSA9IG5hbWU7XG4gIH1cblxuICBpZiAoaWNvbikge1xuICAgIHJlc3VsdC5pY29uID0gaWNvbjtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbkxpc3QgJiYgY2hpbGRyZW5MaXN0Lmxlbmd0aCkge1xuICAgIC8qKiDlnKjoj5zljZXkuK3pmpDol4/lrZDpobkgKi9cbiAgICBpZiAoaGlkZUNoaWxkcmVuKSB7XG4gICAgICBkZWxldGUgcmVzdWx0LmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IC8vIOmcgOimgemHjeaWsOi/m+ihjOS4gOasoVxuXG5cbiAgICB2YXIgZmluYWxDaGlsZHJlbiA9IGZvcm1hdHRlcihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgIGRhdGE6IGNoaWxkcmVuTGlzdFxuICAgIH0pLCByb3V0ZSk7XG4gICAgLyoqIOWcqOiPnOWNleS4reWPqumakOiXj+atpOmhue+8jOWtkOmhueW+gOS4iuaPkO+8jOS7jeaXp+WxleekuiAqL1xuXG4gICAgaWYgKGZsYXRNZW51KSB7XG4gICAgICByZXR1cm4gZmluYWxDaGlsZHJlbjtcbiAgICB9XG5cbiAgICBkZWxldGUgcmVzdWx0W2NoaWxkcmVuUHJvcHNOYW1lXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgbm90TnVsbEFycmF5ID0gZnVuY3Rpb24gbm90TnVsbEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBwcm9wc1xuICogQHBhcmFtIHBhcmVudFxuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0dGVyKHByb3BzKSB7XG4gIHZhciBwYXJlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBwYXRoOiAnLydcbiAgfTtcbiAgdmFyIGRhdGEgPSBwcm9wcy5kYXRhLFxuICAgICAgZm9ybWF0TWVzc2FnZSA9IHByb3BzLmZvcm1hdE1lc3NhZ2UsXG4gICAgICBwYXJlbnROYW1lID0gcHJvcHMucGFyZW50TmFtZSxcbiAgICAgIG1lbnVMb2NhbGUgPSBwcm9wcy5sb2NhbGU7XG5cbiAgaWYgKCFkYXRhIHx8ICFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGRhdGEuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5vdE51bGxBcnJheShpdGVtLmNoaWxkcmVuKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGl0ZW0ucGF0aCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGl0ZW0ub3JpZ2luUGF0aCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGl0ZW0ubGF5b3V0KSByZXR1cm4gdHJ1ZTsgLy8g6YeN5a6a5ZCRXG5cbiAgICBpZiAoaXRlbS5yZWRpcmVjdCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpdGVtLnVuYWNjZXNzaWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIF9pdGVtJG1lbnUsIF9pdGVtJG1lbnUyO1xuXG4gICAgaWYgKChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaXRlbSRtZW51ID0gaXRlbS5tZW51KSA9PT0gbnVsbCB8fCBfaXRlbSRtZW51ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaXRlbSRtZW51Lm5hbWUpIHx8IChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGl0ZW0uZmxhdE1lbnUpIHx8IChpdGVtID09PSBudWxsIHx8IGl0ZW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaXRlbSRtZW51MiA9IGl0ZW0ubWVudSkgPT09IG51bGwgfHwgX2l0ZW0kbWVudTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVtJG1lbnUyLmZsYXRNZW51KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyDmmL7npLrmjIflrprlnKggbWVudSDkuK3pmpDol4/or6XpoblcbiAgICAvLyBsYXlvdXQg5o+S5Lu255qE5Yqf6IO977yM5YW25a6e5LiN5bqU6K+l5a2Y5Zyo55qEXG5cblxuICAgIGlmIChpdGVtLm1lbnUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pLm1hcChmdW5jdGlvbiAoZmluYWxseUl0ZW0pIHtcbiAgICB2YXIgaXRlbSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZmluYWxseUl0ZW0pLCB7fSwge1xuICAgICAgcGF0aDogZmluYWxseUl0ZW0ucGF0aCB8fCBmaW5hbGx5SXRlbS5vcmlnaW5QYXRoXG4gICAgfSk7XG5cbiAgICBpZiAoIWl0ZW0uY2hpbGRyZW4gJiYgaXRlbVtjaGlsZHJlblByb3BzTmFtZV0pIHtcbiAgICAgIGl0ZW0uY2hpbGRyZW4gPSBpdGVtW2NoaWxkcmVuUHJvcHNOYW1lXTtcbiAgICAgIGRlbGV0ZSBpdGVtW2NoaWxkcmVuUHJvcHNOYW1lXTtcbiAgICB9IC8vIOaYr+WQpuayoeacieadg+mZkOafpeeci1xuICAgIC8vIOi/meagt+WwseS4jeS8muaYvuekuu+8jOaYr+S4gOS4quWFvOWuueaAp+eahOaWueW8j1xuXG5cbiAgICBpZiAoaXRlbS51bmFjY2Vzc2libGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZGVsZXRlIGl0ZW0ubmFtZTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5wYXRoID09PSAnKicpIHtcbiAgICAgIGl0ZW0ucGF0aCA9ICcuJztcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5wYXRoID09PSAnLyonKSB7XG4gICAgICBpdGVtLnBhdGggPSAnLic7XG4gICAgfVxuXG4gICAgaWYgKCFpdGVtLnBhdGggJiYgaXRlbS5vcmlnaW5QYXRoKSB7XG4gICAgICBpdGVtLnBhdGggPSBpdGVtLm9yaWdpblBhdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHtcbiAgICAgIHBhdGg6ICcvJ1xuICAgIH07XG4gICAgdmFyIHJvdXRlckNoaWxkcmVuID0gaXRlbS5jaGlsZHJlbiB8fCBpdGVtW2NoaWxkcmVuUHJvcHNOYW1lXSB8fCBbXTtcbiAgICB2YXIgcGF0aCA9IG1lcmdlUGF0aChpdGVtLnBhdGgsIHBhcmVudCA/IHBhcmVudC5wYXRoIDogJy8nKTtcbiAgICB2YXIgbmFtZSA9IGl0ZW0ubmFtZTtcbiAgICB2YXIgbG9jYWxlID0gZ2V0SXRlbUxvY2FsZU5hbWUoaXRlbSwgcGFyZW50TmFtZSB8fCAnbWVudScpOyAvLyBpZiBlbmFibGVNZW51TG9jYWxlIHVzZSBpdGVtLm5hbWUsXG4gICAgLy8gY2xvc2UgbWVudSBpbnRlcm5hdGlvbmFsXG5cbiAgICB2YXIgbG9jYWxlTmFtZSA9IGxvY2FsZSAhPT0gZmFsc2UgJiYgbWVudUxvY2FsZSAhPT0gZmFsc2UgJiYgZm9ybWF0TWVzc2FnZSAmJiBsb2NhbGUgPyBmb3JtYXRNZXNzYWdlKHtcbiAgICAgIGlkOiBsb2NhbGUsXG4gICAgICBkZWZhdWx0TWVzc2FnZTogbmFtZVxuICAgIH0pIDogbmFtZTtcblxuICAgIHZhciBfcGFyZW50JHByb19sYXlvdXRfcGEgPSBwYXJlbnQucHJvX2xheW91dF9wYXJlbnRLZXlzLFxuICAgICAgICBwcm9fbGF5b3V0X3BhcmVudEtleXMgPSBfcGFyZW50JHByb19sYXlvdXRfcGEgPT09IHZvaWQgMCA/IFtdIDogX3BhcmVudCRwcm9fbGF5b3V0X3BhLFxuICAgICAgICBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgICAgaWNvbiA9IHBhcmVudC5pY29uLFxuICAgICAgICBmbGF0TWVudSA9IHBhcmVudC5mbGF0TWVudSxcbiAgICAgICAgaW5kZXhSb3V0ZSA9IHBhcmVudC5pbmRleFJvdXRlLFxuICAgICAgICByb3V0ZXMgPSBwYXJlbnQucm91dGVzLFxuICAgICAgICByZXN0UGFyZW50ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHBhcmVudCwgX2V4Y2x1ZGVkKTtcblxuICAgIHZhciBpdGVtX3Byb19sYXlvdXRfcGFyZW50S2V5cyA9IG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwcm9fbGF5b3V0X3BhcmVudEtleXMpLCBfdG9Db25zdW1hYmxlQXJyYXkoaXRlbS5wYXJlbnRLZXlzIHx8IFtdKSkpO1xuXG4gICAgaWYgKHBhcmVudC5rZXkpIHtcbiAgICAgIGl0ZW1fcHJvX2xheW91dF9wYXJlbnRLZXlzLmFkZChwYXJlbnQua2V5KTtcbiAgICB9XG5cbiAgICB2YXIgZmluYWxseUl0ZW0gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdFBhcmVudCksIHt9LCB7XG4gICAgICBtZW51OiB1bmRlZmluZWRcbiAgICB9LCBpdGVtKSwge30sIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIGtleTogaXRlbS5rZXkgfHwgZ2V0S2V5QnlQYXRoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaXRlbSksIHt9LCB7XG4gICAgICAgIHBhdGg6IHBhdGhcbiAgICAgIH0pKSxcbiAgICAgIHByb19sYXlvdXRfcGFyZW50S2V5czogQXJyYXkuZnJvbShpdGVtX3Byb19sYXlvdXRfcGFyZW50S2V5cykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSAmJiBrZXkgIT09ICcvJztcbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAobG9jYWxlTmFtZSkge1xuICAgICAgZmluYWxseUl0ZW0ubmFtZSA9IGxvY2FsZU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBmaW5hbGx5SXRlbS5uYW1lO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGx5SXRlbS5tZW51ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBmaW5hbGx5SXRlbS5tZW51O1xuICAgIH1cblxuICAgIGlmIChub3ROdWxsQXJyYXkocm91dGVyQ2hpbGRyZW4pKSB7XG4gICAgICB2YXIgZm9ybWF0dGVyQ2hpbGRyZW4gPSBmb3JtYXR0ZXIoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgIGRhdGE6IHJvdXRlckNoaWxkcmVuLFxuICAgICAgICBwYXJlbnROYW1lOiBsb2NhbGUgfHwgJydcbiAgICAgIH0pLCBmaW5hbGx5SXRlbSk7XG5cbiAgICAgIGlmIChub3ROdWxsQXJyYXkoZm9ybWF0dGVyQ2hpbGRyZW4pKSB7XG4gICAgICAgIGZpbmFsbHlJdGVtLmNoaWxkcmVuID0gZm9ybWF0dGVyQ2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpZ2Zpc2hDb21wYXRpYmxlQ29udmVyc2lvbnMoZmluYWxseUl0ZW0sIHByb3BzKTtcbiAgfSkuZmxhdCgxKTtcbn1cbi8qKlxuICog5Yig6ZmkIGhpZGVJbk1lbnUg5ZKMIGl0ZW0ubmFtZSDkuI3lrZjlnKjnmoRcbiAqL1xuXG5cbnZhciBkZWZhdWx0RmlsdGVyTWVudURhdGEgPSBmdW5jdGlvbiBkZWZhdWx0RmlsdGVyTWVudURhdGEoKSB7XG4gIHZhciBtZW51RGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIHJldHVybiBtZW51RGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSAmJiAoaXRlbS5uYW1lIHx8IG5vdE51bGxBcnJheShpdGVtLmNoaWxkcmVuKSkgJiYgIWl0ZW0uaGlkZUluTWVudSAmJiAhaXRlbS5yZWRpcmVjdDtcbiAgfSkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIG5ld0l0ZW0gPSBfb2JqZWN0U3ByZWFkKHt9LCBpdGVtKTtcblxuICAgIHZhciByb3V0ZXJDaGlsZHJlbiA9IG5ld0l0ZW0uY2hpbGRyZW4gfHwgaXRlbVtjaGlsZHJlblByb3BzTmFtZV0gfHwgW107XG4gICAgZGVsZXRlIG5ld0l0ZW1bY2hpbGRyZW5Qcm9wc05hbWVdO1xuXG4gICAgaWYgKG5vdE51bGxBcnJheShyb3V0ZXJDaGlsZHJlbikgJiYgIW5ld0l0ZW0uaGlkZUNoaWxkcmVuSW5NZW51ICYmIHJvdXRlckNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQgJiYgISFjaGlsZC5uYW1lO1xuICAgIH0pKSB7XG4gICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBkZWZhdWx0RmlsdGVyTWVudURhdGEocm91dGVyQ2hpbGRyZW4pO1xuICAgICAgaWYgKG5ld0NoaWxkcmVuLmxlbmd0aCkgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbmV3SXRlbSksIHt9LCB7XG4gICAgICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIGl0ZW0pO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSk7XG59O1xuLyoqXG4gKiBzdXBwb3J0IHBhdGhUb1JlZ2V4cCBnZXQgc3RyaW5nXG4gKi9cblxuXG52YXIgUm91dGVMaXN0TWFwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWFwKSB7XG4gIF9pbmhlcml0cyhSb3V0ZUxpc3RNYXAsIF9NYXApO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUm91dGVMaXN0TWFwKTtcblxuICBmdW5jdGlvbiBSb3V0ZUxpc3RNYXAoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlTGlzdE1hcCk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUm91dGVMaXN0TWFwLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHBhdGhuYW1lKSB7XG4gICAgICB2YXIgcm91dGVWYWx1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmVudHJpZXMoKSksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAga2V5ID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICAgICAgdmFyIHBhdGggPSBzdHJpcFF1ZXJ5U3RyaW5nQW5kSGFzaEZyb21QYXRoKGtleSk7XG5cbiAgICAgICAgICAgIGlmICghaXNVcmwoa2V5KSAmJiBwYXRoVG9SZWdleHAocGF0aCwgW10pLnRlc3QocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgIHJvdXRlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJvdXRlVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3V0ZVZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSb3V0ZUxpc3RNYXA7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihNYXApKTtcbi8qKlxuICog6I635Y+W6Z2i5YyF5bGR5pig5bCEXG4gKiBAcGFyYW0gTWVudURhdGFJdGVtW10gbWVudURhdGEg6I+c5Y2V6YWN572uXG4gKi9cblxuXG52YXIgZ2V0QnJlYWRjcnVtYk5hbWVNYXAgPSBmdW5jdGlvbiBnZXRCcmVhZGNydW1iTmFtZU1hcChtZW51RGF0YSkge1xuICAvLyBNYXAgaXMgdXNlZCB0byBlbnN1cmUgdGhlIG9yZGVyIG9mIGtleXNcbiAgdmFyIHJvdXRlck1hcCA9IG5ldyBSb3V0ZUxpc3RNYXAoKTtcblxuICB2YXIgZmxhdHRlbk1lbnVEYXRhID0gZnVuY3Rpb24gZmxhdHRlbk1lbnVEYXRhKGRhdGEsIHBhcmVudCkge1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAobWVudUl0ZW0pIHtcbiAgICAgIHZhciByb3V0ZXJDaGlsZHJlbiA9IG1lbnVJdGVtLmNoaWxkcmVuIHx8IG1lbnVJdGVtW2NoaWxkcmVuUHJvcHNOYW1lXSB8fCBbXTtcblxuICAgICAgaWYgKG5vdE51bGxBcnJheShyb3V0ZXJDaGlsZHJlbikpIHtcbiAgICAgICAgZmxhdHRlbk1lbnVEYXRhKHJvdXRlckNoaWxkcmVuLCBtZW51SXRlbSk7XG4gICAgICB9IC8vIFJlZHVjZSBtZW1vcnkgdXNhZ2VcblxuXG4gICAgICB2YXIgcGF0aCA9IG1lcmdlUGF0aChtZW51SXRlbS5wYXRoLCBwYXJlbnQgPyBwYXJlbnQucGF0aCA6ICcvJyk7XG4gICAgICByb3V0ZXJNYXAuc2V0KHN0cmlwUXVlcnlTdHJpbmdBbmRIYXNoRnJvbVBhdGgocGF0aCksIG1lbnVJdGVtKTtcbiAgICB9KTtcbiAgfTtcblxuICBmbGF0dGVuTWVudURhdGEobWVudURhdGEpO1xuICByZXR1cm4gcm91dGVyTWFwO1xufTtcblxudmFyIGNsZWFyQ2hpbGRyZW4gPSBmdW5jdGlvbiBjbGVhckNoaWxkcmVuKCkge1xuICB2YXIgbWVudURhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICByZXR1cm4gbWVudURhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIHJvdXRlckNoaWxkcmVuID0gaXRlbS5jaGlsZHJlbiB8fCBpdGVtW2NoaWxkcmVuUHJvcHNOYW1lXTtcblxuICAgIGlmIChub3ROdWxsQXJyYXkocm91dGVyQ2hpbGRyZW4pKSB7XG4gICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBjbGVhckNoaWxkcmVuKHJvdXRlckNoaWxkcmVuKTtcbiAgICAgIGlmIChuZXdDaGlsZHJlbi5sZW5ndGgpIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBpdGVtKTtcbiAgICB9XG5cbiAgICB2YXIgZmluYWxseUl0ZW0gPSBfb2JqZWN0U3ByZWFkKHt9LCBpdGVtKTtcblxuICAgIGRlbGV0ZSBmaW5hbGx5SXRlbVtjaGlsZHJlblByb3BzTmFtZV07XG4gICAgZGVsZXRlIGZpbmFsbHlJdGVtLmNoaWxkcmVuO1xuICAgIHJldHVybiBmaW5hbGx5SXRlbTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pO1xufTtcbi8qKlxuICogQHBhcmFtIHJvdXRlTGlzdCDot6/nlLHphY3nva5cbiAqIEBwYXJhbSBsb2NhbGUg5piv5ZCm5L2/55So5Zu96ZmF5YyWXG4gKiBAcGFyYW0gZm9ybWF0TWVzc2FnZSDlm73pmYXljJbnmoTnqIvluo9cbiAqIEBwYXJhbSBpZ25vcmVGaWx0ZXIg5piv5ZCm562b6YCJ5o6J5LiN5bGV56S655qEIG1lbnVJdGVtIOmhue+8jHBsdWdpbi1sYXlvdXTpnIDopoHmiYDmnInpobnnm67mnaXorqHnrpfluIPlsYDmoLflvI9cbiAqIEByZXR1cm5zIHsgYnJlYWRjcnVtYiwgbWVudURhdGF9XG4gKi9cblxuXG52YXIgdHJhbnNmb3JtUm91dGUgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Sb3V0ZShyb3V0ZUxpc3QsIGxvY2FsZSwgZm9ybWF0TWVzc2FnZSwgaWdub3JlRmlsdGVyKSB7XG4gIHZhciBvcmlnaW5hbE1lbnVEYXRhID0gZm9ybWF0dGVyKHtcbiAgICBkYXRhOiByb3V0ZUxpc3QsXG4gICAgZm9ybWF0TWVzc2FnZTogZm9ybWF0TWVzc2FnZSxcbiAgICBsb2NhbGU6IGxvY2FsZVxuICB9KTtcbiAgdmFyIG1lbnVEYXRhID0gaWdub3JlRmlsdGVyID8gY2xlYXJDaGlsZHJlbihvcmlnaW5hbE1lbnVEYXRhKSA6IGRlZmF1bHRGaWx0ZXJNZW51RGF0YShvcmlnaW5hbE1lbnVEYXRhKTsgLy8gTWFwIHR5cGUgdXNlZCBmb3IgaW50ZXJuYWwgbG9naWNcblxuICB2YXIgYnJlYWRjcnVtYiA9IGdldEJyZWFkY3J1bWJOYW1lTWFwKG9yaWdpbmFsTWVudURhdGEpO1xuICByZXR1cm4ge1xuICAgIGJyZWFkY3J1bWI6IGJyZWFkY3J1bWIsXG4gICAgbWVudURhdGE6IG1lbnVEYXRhXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCB0cmFuc2Zvcm1Sb3V0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@umijs/route-utils/es/transformRoute/transformRoute.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@umijs/use-params/es/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@umijs/use-params/es/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useUrlSearchParams: () => (/* binding */ useUrlSearchParams)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n/* eslint-disable no-restricted-syntax */\r\n\r\n/**\r\n *\r\n * @param {object} params\r\n * @returns {URL}\r\n */\r\nfunction setQueryToCurrentUrl(params) {\r\n    var _a;\r\n    var URL = (typeof window !== 'undefined' ? window : {}).URL;\r\n    var url = new URL((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.href);\r\n    Object.keys(params).forEach(function (key) {\r\n        var value = params[key];\r\n        if (value !== null && value !== undefined) {\r\n            if (Array.isArray(value)) {\r\n                url.searchParams.delete(key);\r\n                value.forEach(function (valueItem) {\r\n                    url.searchParams.append(key, valueItem);\r\n                });\r\n            }\r\n            else if (value instanceof Date) {\r\n                if (!Number.isNaN(value.getTime())) {\r\n                    url.searchParams.set(key, value.toISOString());\r\n                }\r\n            }\r\n            else if (typeof value === 'object') {\r\n                url.searchParams.set(key, JSON.stringify(value));\r\n            }\r\n            else {\r\n                url.searchParams.set(key, value);\r\n            }\r\n        }\r\n        else {\r\n            url.searchParams.delete(key);\r\n        }\r\n    });\r\n    return url;\r\n}\r\nfunction useUrlSearchParams(initial, config) {\r\n    var _a;\r\n    if (initial === void 0) { initial = {}; }\r\n    if (config === void 0) { config = { disabled: false }; }\r\n    /**\r\n     * The main idea of this hook is to make things response to change of `window.location.search`,\r\n     * so no need for introducing new state (in the mean time).\r\n     * Whenever `window.location.search` is changed but  not cause re-render, call `forceUpdate()`.\r\n     * Whenever the component - user of this hook - re-render, this hook should return\r\n     * the query object that corresponse to the current `window.location.search`\r\n     */\r\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), forceUpdate = _b[1];\r\n    var locationSearch = typeof window !== 'undefined' && ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.search);\r\n    /**\r\n     * @type {URLSearchParams}\r\n     */\r\n    var urlSearchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\r\n        if (config.disabled)\r\n            return {};\r\n        return new URLSearchParams(locationSearch || {});\r\n    }, [config.disabled, locationSearch]);\r\n    var params = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\r\n        if (config.disabled)\r\n            return {};\r\n        if (typeof window === 'undefined' || !window.URL)\r\n            return {};\r\n        var result = [];\r\n        // @ts-ignore\r\n        urlSearchParams.forEach(function (value, key) {\r\n            result.push({\r\n                key: key,\r\n                value: value,\r\n            });\r\n        });\r\n        // group by key\r\n        result = result.reduce(function (acc, val) {\r\n            (acc[val.key] = acc[val.key] || []).push(val);\r\n            return acc;\r\n        }, {});\r\n        result = Object.keys(result).map(function (key) {\r\n            var valueGroup = result[key];\r\n            if (valueGroup.length === 1) {\r\n                return [key, valueGroup[0].value];\r\n            }\r\n            return [key, valueGroup.map(function (_a) {\r\n                    var value = _a.value;\r\n                    return value;\r\n                })];\r\n        });\r\n        var newParams = __assign({}, initial);\r\n        result.forEach(function (_a) {\r\n            var key = _a[0], value = _a[1];\r\n            newParams[key] = parseValue(key, value, {}, initial);\r\n        });\r\n        return newParams;\r\n    }, [config.disabled, initial, urlSearchParams]);\r\n    function redirectToNewSearchParams(newParams) {\r\n        if (typeof window === 'undefined' || !window.URL)\r\n            return;\r\n        var url = setQueryToCurrentUrl(newParams);\r\n        if (window.location.search !== url.search) {\r\n            window.history.replaceState({}, '', url.toString());\r\n        }\r\n        if (urlSearchParams.toString() !== url.searchParams.toString()) {\r\n            forceUpdate({});\r\n        }\r\n    }\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\r\n        if (config.disabled)\r\n            return;\r\n        if (typeof window === 'undefined' || !window.URL)\r\n            return;\r\n        redirectToNewSearchParams(__assign(__assign({}, initial), params));\r\n    }, [config.disabled, params]);\r\n    var setParams = function (newParams) {\r\n        redirectToNewSearchParams(newParams);\r\n    };\r\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\r\n        if (config.disabled)\r\n            return function () { };\r\n        if (typeof window === 'undefined' || !window.URL)\r\n            return function () { };\r\n        var onPopState = function () {\r\n            forceUpdate({});\r\n        };\r\n        window.addEventListener('popstate', onPopState);\r\n        return function () {\r\n            window.removeEventListener('popstate', onPopState);\r\n        };\r\n    }, [config.disabled]);\r\n    return [params, setParams];\r\n}\r\nvar booleanValues = {\r\n    true: true,\r\n    false: false,\r\n};\r\nfunction parseValue(key, _value, types, defaultParams) {\r\n    if (!types)\r\n        return _value;\r\n    var type = types[key];\r\n    var value = _value === undefined ? defaultParams[key] : _value;\r\n    if (type === Number) {\r\n        return Number(value);\r\n    }\r\n    if (type === Boolean || _value === 'true' || _value === 'false') {\r\n        return booleanValues[value];\r\n    }\r\n    if (Array.isArray(type)) {\r\n        // eslint-disable-next-line eqeqeq\r\n        return type.find(function (item) { return item == value; }) || defaultParams[key];\r\n    }\r\n    return value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHVtaWpzL3VzZS1wYXJhbXMvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0JBQWdCLFNBQUksSUFBSSxTQUFJO0FBQzVCO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3FEO0FBQ3JEO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0EsOEJBQThCO0FBQzlCLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMEJBQTBCLDhDQUFPO0FBQ2pDO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsS0FBSztBQUNMLGlCQUFpQiw4Q0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7QUFDVCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xldHR5Y29kZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdW1panMvdXNlLXBhcmFtcy9lcy9pbmRleC5qcz9mZDZjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXggKi9cclxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcclxuICogQHJldHVybnMge1VSTH1cclxuICovXHJcbmZ1bmN0aW9uIHNldFF1ZXJ5VG9DdXJyZW50VXJsKHBhcmFtcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIFVSTCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KS5VUkw7XHJcbiAgICB2YXIgdXJsID0gbmV3IFVSTCgoX2EgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKTtcclxuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW2tleV07XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWVJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZS50b0lTT1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB1cmw7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVybFNlYXJjaFBhcmFtcyhpbml0aWFsLCBjb25maWcpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmIChpbml0aWFsID09PSB2b2lkIDApIHsgaW5pdGlhbCA9IHt9OyB9XHJcbiAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0geyBkaXNhYmxlZDogZmFsc2UgfTsgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWFpbiBpZGVhIG9mIHRoaXMgaG9vayBpcyB0byBtYWtlIHRoaW5ncyByZXNwb25zZSB0byBjaGFuZ2Ugb2YgYHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hgLFxyXG4gICAgICogc28gbm8gbmVlZCBmb3IgaW50cm9kdWNpbmcgbmV3IHN0YXRlIChpbiB0aGUgbWVhbiB0aW1lKS5cclxuICAgICAqIFdoZW5ldmVyIGB3aW5kb3cubG9jYXRpb24uc2VhcmNoYCBpcyBjaGFuZ2VkIGJ1dCAgbm90IGNhdXNlIHJlLXJlbmRlciwgY2FsbCBgZm9yY2VVcGRhdGUoKWAuXHJcbiAgICAgKiBXaGVuZXZlciB0aGUgY29tcG9uZW50IC0gdXNlciBvZiB0aGlzIGhvb2sgLSByZS1yZW5kZXIsIHRoaXMgaG9vayBzaG91bGQgcmV0dXJuXHJcbiAgICAgKiB0aGUgcXVlcnkgb2JqZWN0IHRoYXQgY29ycmVzcG9uc2UgdG8gdGhlIGN1cnJlbnQgYHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hgXHJcbiAgICAgKi9cclxuICAgIHZhciBfYiA9IHVzZVN0YXRlKCksIGZvcmNlVXBkYXRlID0gX2JbMV07XHJcbiAgICB2YXIgbG9jYXRpb25TZWFyY2ggPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VhcmNoKTtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge1VSTFNlYXJjaFBhcmFtc31cclxuICAgICAqL1xyXG4gICAgdmFyIHVybFNlYXJjaFBhcmFtcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjb25maWcuZGlzYWJsZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvblNlYXJjaCB8fCB7fSk7XHJcbiAgICB9LCBbY29uZmlnLmRpc2FibGVkLCBsb2NhdGlvblNlYXJjaF0pO1xyXG4gICAgdmFyIHBhcmFtcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjb25maWcuZGlzYWJsZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5VUkwpXHJcbiAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHVybFNlYXJjaFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBncm91cCBieSBrZXlcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xyXG4gICAgICAgICAgICAoYWNjW3ZhbC5rZXldID0gYWNjW3ZhbC5rZXldIHx8IFtdKS5wdXNoKHZhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIHJlc3VsdCA9IE9iamVjdC5rZXlzKHJlc3VsdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlR3JvdXAgPSByZXN1bHRba2V5XTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlR3JvdXAubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVHcm91cFswXS52YWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlR3JvdXAubWFwKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgbmV3UGFyYW1zID0gX19hc3NpZ24oe30sIGluaXRpYWwpO1xyXG4gICAgICAgIHJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XHJcbiAgICAgICAgICAgIG5ld1BhcmFtc1trZXldID0gcGFyc2VWYWx1ZShrZXksIHZhbHVlLCB7fSwgaW5pdGlhbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcclxuICAgIH0sIFtjb25maWcuZGlzYWJsZWQsIGluaXRpYWwsIHVybFNlYXJjaFBhcmFtc10pO1xyXG4gICAgZnVuY3Rpb24gcmVkaXJlY3RUb05ld1NlYXJjaFBhcmFtcyhuZXdQYXJhbXMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5VUkwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2YXIgdXJsID0gc2V0UXVlcnlUb0N1cnJlbnRVcmwobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLnNlYXJjaCAhPT0gdXJsLnNlYXJjaCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCB1cmwudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cmxTZWFyY2hQYXJhbXMudG9TdHJpbmcoKSAhPT0gdXJsLnNlYXJjaFBhcmFtcy50b1N0cmluZygpKSB7XHJcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHt9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjb25maWcuZGlzYWJsZWQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5VUkwpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICByZWRpcmVjdFRvTmV3U2VhcmNoUGFyYW1zKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbml0aWFsKSwgcGFyYW1zKSk7XHJcbiAgICB9LCBbY29uZmlnLmRpc2FibGVkLCBwYXJhbXNdKTtcclxuICAgIHZhciBzZXRQYXJhbXMgPSBmdW5jdGlvbiAobmV3UGFyYW1zKSB7XHJcbiAgICAgICAgcmVkaXJlY3RUb05ld1NlYXJjaFBhcmFtcyhuZXdQYXJhbXMpO1xyXG4gICAgfTtcclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5kaXNhYmxlZClcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5VUkwpXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgdmFyIG9uUG9wU3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHt9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbY29uZmlnLmRpc2FibGVkXSk7XHJcbiAgICByZXR1cm4gW3BhcmFtcywgc2V0UGFyYW1zXTtcclxufVxyXG52YXIgYm9vbGVhblZhbHVlcyA9IHtcclxuICAgIHRydWU6IHRydWUsXHJcbiAgICBmYWxzZTogZmFsc2UsXHJcbn07XHJcbmZ1bmN0aW9uIHBhcnNlVmFsdWUoa2V5LCBfdmFsdWUsIHR5cGVzLCBkZWZhdWx0UGFyYW1zKSB7XHJcbiAgICBpZiAoIXR5cGVzKVxyXG4gICAgICAgIHJldHVybiBfdmFsdWU7XHJcbiAgICB2YXIgdHlwZSA9IHR5cGVzW2tleV07XHJcbiAgICB2YXIgdmFsdWUgPSBfdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRQYXJhbXNba2V5XSA6IF92YWx1ZTtcclxuICAgIGlmICh0eXBlID09PSBOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlID09PSBCb29sZWFuIHx8IF92YWx1ZSA9PT0gJ3RydWUnIHx8IF92YWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgIHJldHVybiBib29sZWFuVmFsdWVzW3ZhbHVlXTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgICAgIHJldHVybiB0eXBlLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gPT0gdmFsdWU7IH0pIHx8IGRlZmF1bHRQYXJhbXNba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@umijs/use-params/es/index.js\n");

/***/ })

};
;