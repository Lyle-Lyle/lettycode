"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hast-util-raw";
exports.ids = ["vendor-chunks/hast-util-raw"];
exports.modules = {

/***/ "(ssr)/./node_modules/hast-util-raw/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/hast-util-raw/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raw: () => (/* binding */ raw)\n/* harmony export */ });\n/* harmony import */ var parse5_lib_parser_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parse5/lib/parser/index.js */ \"(ssr)/./node_modules/parse5/lib/parser/index.js\");\n/* harmony import */ var unist_util_position__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! unist-util-position */ \"(ssr)/./node_modules/unist-util-position/lib/index.js\");\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unist-util-visit */ \"(ssr)/./node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hast-util-from-parse5 */ \"(ssr)/./node_modules/hast-util-from-parse5/lib/index.js\");\n/* harmony import */ var hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! hast-util-to-parse5 */ \"(ssr)/./node_modules/hast-util-to-parse5/lib/index.js\");\n/* harmony import */ var html_void_elements__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! html-void-elements */ \"(ssr)/./node_modules/html-void-elements/index.js\");\n/* harmony import */ var web_namespaces__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! web-namespaces */ \"(ssr)/./node_modules/web-namespaces/index.js\");\n/* harmony import */ var zwitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zwitch */ \"(ssr)/./node_modules/zwitch/index.js\");\n/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('parse5').Document} P5Document\n * @typedef {import('parse5').DocumentFragment} P5Fragment\n * @typedef {Omit<import('parse5').Element, 'parentNode'>} P5Element\n * @typedef {import('parse5').Attribute} P5Attribute\n * @typedef {Omit<import('parse5').Location, 'startOffset' | 'endOffset'> & {startOffset: number|undefined, endOffset: number|undefined}} P5Location\n * @typedef {import('parse5').ParserOptions} P5ParserOptions\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').DocType} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {import('../complex-types').Raw} Raw\n *\n * @typedef {Omit<Comment, 'value'> & {value: {stitch: Node}}} Stitch\n *\n * @typedef Options\n * @property {Array<string>} [passThrough]\n *   List of custom hast node types to pass through (keep) in hast.\n *   If the passed through nodes have children, those children are expected to\n *   be hast and will be handled.\n *\n * @typedef HiddenTokenizer\n * @property {Array<HiddenLocationTracker>} __mixins\n *   Way too simple, but works for us.\n * @property {HiddenPreprocessor} preprocessor\n * @property {(value: string) => void} write\n * @property {() => number} _consume\n * @property {Array<HiddenToken>} tokenQueue\n * @property {string} state\n * @property {string} returnState\n * @property {number} charRefCode\n * @property {Array<number>} tempBuff\n * @property {Function} _flushCodePointsConsumedAsCharacterReference\n * @property {string} lastStartTagName\n * @property {number} consumedAfterSnapshot\n * @property {boolean} active\n * @property {HiddenToken|undefined} currentCharacterToken\n * @property {HiddenToken|undefined} currentToken\n * @property {unknown} currentAttr\n * @property {Function} NAMED_CHARACTER_REFERENCE_STATE\n * @property {Function} NUMERIC_CHARACTER_REFERENCE_END_STATE\n *\n * @typedef {Record<string, unknown> & {location: P5Location}} HiddenToken\n *\n * @typedef HiddenPreprocessor\n * @property {string|undefined} html\n * @property {number} pos\n * @property {number} lastGapPos\n * @property {number} lastCharPos\n * @property {Array<number>} gapStack\n * @property {boolean} skipNextNewLine\n * @property {boolean} lastChunkWritten\n * @property {boolean} endOfChunkHit\n *\n * @typedef HiddenLocationTracker\n * @property {P5Location|undefined} currentAttrLocation\n * @property {P5Location} ctLoc\n * @property {HiddenPosTracker} posTracker\n *\n * @typedef HiddenPosTracker\n * @property {boolean} isEol\n * @property {number} lineStartPos\n * @property {number} droppedBufferSize\n * @property {number} offset\n * @property {number} col\n * @property {number} line\n */\n\n// @ts-expect-error: untyped.\n\n\n\n\n\n\n\n\n\nconst inTemplateMode = 'IN_TEMPLATE_MODE'\nconst dataState = 'DATA_STATE'\nconst characterToken = 'CHARACTER_TOKEN'\nconst startTagToken = 'START_TAG_TOKEN'\nconst endTagToken = 'END_TAG_TOKEN'\nconst commentToken = 'COMMENT_TOKEN'\nconst doctypeToken = 'DOCTYPE_TOKEN'\n\n/** @type {P5ParserOptions} */\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\n\n/**\n * Given a hast tree and an optional vfile (for positional info), return a new\n * parsed-again hast tree.\n *\n * @param tree\n *   Original hast tree.\n * @param file\n *   Virtual file for positional info, optional.\n * @param options\n *   Configuration.\n */\nconst raw =\n  /**\n   * @type {(\n   *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &\n   *   ((tree: Node, options?: Options) => Node)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {VFile} [file]\n     * @param {Options} [options]\n     */\n    function (tree, file, options) {\n      let index = -1\n      const parser = new parse5_lib_parser_index_js__WEBPACK_IMPORTED_MODULE_0__(parseOptions)\n      const one = (0,zwitch__WEBPACK_IMPORTED_MODULE_1__.zwitch)('type', {\n        handlers: {root, element, text, comment, doctype, raw: handleRaw},\n        // @ts-expect-error: hush.\n        unknown\n      })\n      /** @type {boolean|undefined} */\n      let stitches\n      /** @type {HiddenTokenizer|undefined} */\n      let tokenizer\n      /** @type {HiddenPreprocessor|undefined} */\n      let preprocessor\n      /** @type {HiddenPosTracker|undefined} */\n      let posTracker\n      /** @type {HiddenLocationTracker|undefined} */\n      let locationTracker\n\n      if (isOptions(file)) {\n        options = file\n        file = undefined\n      }\n\n      if (options && options.passThrough) {\n        while (++index < options.passThrough.length) {\n          // @ts-expect-error: hush.\n          one.handlers[options.passThrough[index]] = stitch\n        }\n      }\n\n      const result = (0,hast_util_from_parse5__WEBPACK_IMPORTED_MODULE_2__.fromParse5)(\n        documentMode(tree) ? document() : fragment(),\n        file\n      )\n\n      if (stitches) {\n        (0,unist_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(result, 'comment', (node, index, parent) => {\n          const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\n          if (stitch.value.stitch && parent !== null && index !== null) {\n            // @ts-expect-error: assume the stitch is allowed.\n            parent.children[index] = stitch.value.stitch\n            return index\n          }\n        })\n      }\n\n      // Unpack if possible and when not given a `root`.\n      if (\n        tree.type !== 'root' &&\n        result.type === 'root' &&\n        result.children.length === 1\n      ) {\n        return result.children[0]\n      }\n\n      return result\n\n      /**\n       * @returns {P5Fragment}\n       */\n      function fragment() {\n        /** @type {P5Element} */\n        const context = {\n          nodeName: 'template',\n          tagName: 'template',\n          attrs: [],\n          namespaceURI: web_namespaces__WEBPACK_IMPORTED_MODULE_4__.webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Element} */\n        const mock = {\n          nodeName: 'documentmock',\n          tagName: 'documentmock',\n          attrs: [],\n          namespaceURI: web_namespaces__WEBPACK_IMPORTED_MODULE_4__.webNamespaces.html,\n          childNodes: []\n        }\n        /** @type {P5Fragment} */\n        const doc = {nodeName: '#document-fragment', childNodes: []}\n\n        parser._bootstrap(mock, context)\n        parser._pushTmplInsertionMode(inTemplateMode)\n        parser._initTokenizerForFragmentParsing()\n        parser._insertFakeRootElement()\n        parser._resetInsertionMode()\n        parser._findFormInFragmentContext()\n\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        parser._adoptNodes(mock.childNodes[0], doc)\n\n        return doc\n      }\n\n      /**\n       * @returns {P5Document}\n       */\n      function document() {\n        /** @type {P5Document} */\n        const doc = parser.treeAdapter.createDocument()\n\n        parser._bootstrap(doc, undefined)\n        tokenizer = parser.tokenizer\n        /* c8 ignore next */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        preprocessor = tokenizer.preprocessor\n        locationTracker = tokenizer.__mixins[0]\n        posTracker = locationTracker.posTracker\n\n        one(tree)\n\n        resetTokenizer()\n\n        return doc\n      }\n\n      /**\n       * @param {Array<Content>} nodes\n       * @returns {void}\n       */\n      function all(nodes) {\n        let index = -1\n\n        /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n        if (nodes) {\n          while (++index < nodes.length) {\n            one(nodes[index])\n          }\n        }\n      }\n\n      /**\n       * @param {Root} node\n       * @returns {void}\n       */\n      function root(node) {\n        all(node.children)\n      }\n\n      /**\n       * @param {Element} node\n       * @returns {void}\n       */\n      function element(node) {\n        resetTokenizer()\n        parser._processInputToken(startTag(node))\n\n        all(node.children)\n\n        if (!html_void_elements__WEBPACK_IMPORTED_MODULE_5__.htmlVoidElements.includes(node.tagName)) {\n          resetTokenizer()\n          parser._processInputToken(endTag(node))\n        }\n      }\n\n      /**\n       * @param {Text} node\n       * @returns {void}\n       */\n      function text(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: characterToken,\n          chars: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Doctype} node\n       * @returns {void}\n       */\n      function doctype(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: doctypeToken,\n          name: 'html',\n          forceQuirks: false,\n          publicId: '',\n          systemId: '',\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Comment|Stitch} node\n       * @returns {void}\n       */\n      function comment(node) {\n        resetTokenizer()\n        parser._processInputToken({\n          type: commentToken,\n          data: node.value,\n          location: createParse5Location(node)\n        })\n      }\n\n      /**\n       * @param {Raw} node\n       * @returns {void}\n       */\n      function handleRaw(node) {\n        const start = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_6__.pointStart)(node)\n        const line = start.line || 1\n        const column = start.column || 1\n        const offset = start.offset || 0\n\n        /* c8 ignore next 4 */\n        if (!preprocessor) throw new Error('Expected `preprocessor`')\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n        if (!locationTracker) throw new Error('Expected `locationTracker`')\n\n        // Reset preprocessor:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/preprocessor.js#L17>.\n        preprocessor.html = undefined\n        preprocessor.pos = -1\n        preprocessor.lastGapPos = -1\n        preprocessor.lastCharPos = -1\n        preprocessor.gapStack = []\n        preprocessor.skipNextNewLine = false\n        preprocessor.lastChunkWritten = false\n        preprocessor.endOfChunkHit = false\n\n        // Reset preprocessor mixin:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/position-tracking/preprocessor-mixin.js>.\n        posTracker.isEol = false\n        posTracker.lineStartPos = -column + 1 // Looks weird, but ensures we get correct positional info.\n        posTracker.droppedBufferSize = offset\n        posTracker.offset = 0\n        posTracker.col = 1\n        posTracker.line = line\n\n        // Reset location tracker:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js>.\n        locationTracker.currentAttrLocation = undefined\n        locationTracker.ctLoc = createParse5Location(node)\n\n        // See the code for `parse` and `parseFragment`:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/parser/index.js#L371>.\n        tokenizer.write(node.value)\n        parser._runParsingLoop(null)\n\n        // Character references hang, so if we ended there, we need to flush\n        // those too.\n        // We reset the preprocessor as if the document ends here.\n        // Then one single call to the relevant state does the trick, parse5\n        // consumes the whole token.\n        if (\n          tokenizer.state === 'NAMED_CHARACTER_REFERENCE_STATE' ||\n          tokenizer.state === 'NUMERIC_CHARACTER_REFERENCE_END_STATE'\n        ) {\n          preprocessor.lastChunkWritten = true\n          tokenizer[tokenizer.state](tokenizer._consume())\n        }\n      }\n\n      /**\n       * @param {Node} node\n       */\n      function stitch(node) {\n        stitches = true\n\n        /** @type {Node} */\n        let clone\n\n        // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n        // passed through node).\n        if ('children' in node) {\n          clone = {\n            ...node,\n            children: raw(\n              {type: 'root', children: node.children},\n              file,\n              options\n              // @ts-expect-error Assume a given parent yields a parent.\n            ).children\n          }\n        } else {\n          clone = {...node}\n        }\n\n        // Hack: `value` is supposed to be a string, but as none of the tools\n        // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n        // through.\n        comment({type: 'comment', value: {stitch: clone}})\n      }\n\n      function resetTokenizer() {\n        /* c8 ignore next 2 */\n        if (!tokenizer) throw new Error('Expected `tokenizer`')\n        if (!posTracker) throw new Error('Expected `posTracker`')\n\n        // Process final characters if they’re still there after hibernating.\n        // Similar to:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/extensions/location-info/tokenizer-mixin.js#L95>.\n        const token = tokenizer.currentCharacterToken\n\n        if (token) {\n          token.location.endLine = posTracker.line\n          token.location.endCol = posTracker.col + 1\n          token.location.endOffset = posTracker.offset + 1\n          parser._processInputToken(token)\n        }\n\n        // Reset tokenizer:\n        // See: <https://github.com/inikulin/parse5/blob/9c683e1/packages/parse5/lib/tokenizer/index.js#L218-L234>.\n        // Especially putting it back in the `data` state is useful: some elements,\n        // like textareas and iframes, change the state.\n        // See GH-7.\n        // But also if broken HTML is in `raw`, and then a correct element is given.\n        // See GH-11.\n        tokenizer.tokenQueue = []\n        tokenizer.state = dataState\n        tokenizer.returnState = ''\n        tokenizer.charRefCode = -1\n        tokenizer.tempBuff = []\n        tokenizer.lastStartTagName = ''\n        tokenizer.consumedAfterSnapshot = -1\n        tokenizer.active = false\n        tokenizer.currentCharacterToken = undefined\n        tokenizer.currentToken = undefined\n        tokenizer.currentAttr = undefined\n      }\n    }\n  )\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction startTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: startTagToken,\n    tagName: node.tagName,\n    selfClosing: false,\n    attrs: attributes(node),\n    location\n  }\n}\n\n/**\n * @param {Element} node\n * @returns {Array<P5Attribute>}\n */\nfunction attributes(node) {\n  return (0,hast_util_to_parse5__WEBPACK_IMPORTED_MODULE_7__.toParse5)({\n    tagName: node.tagName,\n    type: 'element',\n    properties: node.properties,\n    children: []\n    // @ts-expect-error Assume element.\n  }).attrs\n}\n\n/**\n * @param {Element} node\n * @returns {HiddenToken}\n */\nfunction endTag(node) {\n  /** @type {P5Location} */\n  const location = Object.assign(createParse5Location(node))\n  // @ts-expect-error extra positional info.\n  location.startTag = Object.assign({}, location)\n\n  // Untyped token.\n  return {\n    type: endTagToken,\n    tagName: node.tagName,\n    attrs: [],\n    location\n  }\n}\n\n/**\n * @param {Node} node\n */\nfunction unknown(node) {\n  throw new Error('Cannot compile `' + node.type + '` node')\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node\n  return Boolean(\n    head &&\n      (head.type === 'doctype' ||\n        (head.type === 'element' && head.tagName === 'html'))\n  )\n}\n\n/**\n * @param {Node|Stitch} node\n * @returns {P5Location}\n */\nfunction createParse5Location(node) {\n  const start = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_6__.pointStart)(node)\n  const end = (0,unist_util_position__WEBPACK_IMPORTED_MODULE_6__.pointEnd)(node)\n\n  return {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  }\n}\n\n/**\n * @param {VFile|Options|undefined} value\n * @return {value is Options}\n */\nfunction isOptions(value) {\n  return Boolean(value && !('message' in value && 'messages' in value))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFzdC11dGlsLXJhdy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQyxhQUFhLDJCQUEyQjtBQUN4QyxhQUFhLG1DQUFtQztBQUNoRCxhQUFhLDhDQUE4QztBQUMzRCxhQUFhLDRCQUE0QjtBQUN6QyxhQUFhLGdFQUFnRSw2REFBNkQ7QUFDMUksYUFBYSxnQ0FBZ0M7QUFDN0MsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxxQkFBcUI7QUFDbEMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSxjQUFjO0FBQzNCLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0EsYUFBYSwwQkFBMEIsUUFBUSxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLHlCQUF5QjtBQUN2QyxjQUFjLGNBQWM7QUFDNUIsY0FBYyxvQkFBb0I7QUFDbEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLFNBQVM7QUFDdkIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QjtBQUNBLGFBQWEsMkJBQTJCLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsU0FB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QUNiO0FBQ0E7QUFDQSxTQUFTLDZEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFVO0FBQzFCLGNBQWMsNkRBQVE7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xldHR5Y29kZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9oYXN0LXV0aWwtcmF3L2xpYi9pbmRleC5qcz84MTI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgndmZpbGUnKS5WRmlsZX0gVkZpbGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3BhcnNlNScpLkRvY3VtZW50fSBQNURvY3VtZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdwYXJzZTUnKS5Eb2N1bWVudEZyYWdtZW50fSBQNUZyYWdtZW50XG4gKiBAdHlwZWRlZiB7T21pdDxpbXBvcnQoJ3BhcnNlNScpLkVsZW1lbnQsICdwYXJlbnROb2RlJz59IFA1RWxlbWVudFxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuQXR0cmlidXRlfSBQNUF0dHJpYnV0ZVxuICogQHR5cGVkZWYge09taXQ8aW1wb3J0KCdwYXJzZTUnKS5Mb2NhdGlvbiwgJ3N0YXJ0T2Zmc2V0JyB8ICdlbmRPZmZzZXQnPiAmIHtzdGFydE9mZnNldDogbnVtYmVyfHVuZGVmaW5lZCwgZW5kT2Zmc2V0OiBudW1iZXJ8dW5kZWZpbmVkfX0gUDVMb2NhdGlvblxuICogQHR5cGVkZWYge2ltcG9ydCgncGFyc2U1JykuUGFyc2VyT3B0aW9uc30gUDVQYXJzZXJPcHRpb25zXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuUm9vdH0gUm9vdFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLkRvY1R5cGV9IERvY3R5cGVcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5FbGVtZW50fSBFbGVtZW50XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdoYXN0JykuVGV4dH0gVGV4dFxuICogQHR5cGVkZWYge2ltcG9ydCgnaGFzdCcpLkNvbW1lbnR9IENvbW1lbnRcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ2hhc3QnKS5Db250ZW50fSBDb250ZW50XG4gKiBAdHlwZWRlZiB7Um9vdHxDb250ZW50fSBOb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb21wbGV4LXR5cGVzJykuUmF3fSBSYXdcbiAqXG4gKiBAdHlwZWRlZiB7T21pdDxDb21tZW50LCAndmFsdWUnPiAmIHt2YWx1ZToge3N0aXRjaDogTm9kZX19fSBTdGl0Y2hcbiAqXG4gKiBAdHlwZWRlZiBPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFtwYXNzVGhyb3VnaF1cbiAqICAgTGlzdCBvZiBjdXN0b20gaGFzdCBub2RlIHR5cGVzIHRvIHBhc3MgdGhyb3VnaCAoa2VlcCkgaW4gaGFzdC5cbiAqICAgSWYgdGhlIHBhc3NlZCB0aHJvdWdoIG5vZGVzIGhhdmUgY2hpbGRyZW4sIHRob3NlIGNoaWxkcmVuIGFyZSBleHBlY3RlZCB0b1xuICogICBiZSBoYXN0IGFuZCB3aWxsIGJlIGhhbmRsZWQuXG4gKlxuICogQHR5cGVkZWYgSGlkZGVuVG9rZW5pemVyXG4gKiBAcHJvcGVydHkge0FycmF5PEhpZGRlbkxvY2F0aW9uVHJhY2tlcj59IF9fbWl4aW5zXG4gKiAgIFdheSB0b28gc2ltcGxlLCBidXQgd29ya3MgZm9yIHVzLlxuICogQHByb3BlcnR5IHtIaWRkZW5QcmVwcm9jZXNzb3J9IHByZXByb2Nlc3NvclxuICogQHByb3BlcnR5IHsodmFsdWU6IHN0cmluZykgPT4gdm9pZH0gd3JpdGVcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gbnVtYmVyfSBfY29uc3VtZVxuICogQHByb3BlcnR5IHtBcnJheTxIaWRkZW5Ub2tlbj59IHRva2VuUXVldWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdGF0ZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJldHVyblN0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2hhclJlZkNvZGVcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdGVtcEJ1ZmZcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IF9mbHVzaENvZGVQb2ludHNDb25zdW1lZEFzQ2hhcmFjdGVyUmVmZXJlbmNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFzdFN0YXJ0VGFnTmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbnN1bWVkQWZ0ZXJTbmFwc2hvdFxuICogQHByb3BlcnR5IHtib29sZWFufSBhY3RpdmVcbiAqIEBwcm9wZXJ0eSB7SGlkZGVuVG9rZW58dW5kZWZpbmVkfSBjdXJyZW50Q2hhcmFjdGVyVG9rZW5cbiAqIEBwcm9wZXJ0eSB7SGlkZGVuVG9rZW58dW5kZWZpbmVkfSBjdXJyZW50VG9rZW5cbiAqIEBwcm9wZXJ0eSB7dW5rbm93bn0gY3VycmVudEF0dHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IE5BTUVEX0NIQVJBQ1RFUl9SRUZFUkVOQ0VfU1RBVEVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IE5VTUVSSUNfQ0hBUkFDVEVSX1JFRkVSRU5DRV9FTkRfU1RBVEVcbiAqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPHN0cmluZywgdW5rbm93bj4gJiB7bG9jYXRpb246IFA1TG9jYXRpb259fSBIaWRkZW5Ub2tlblxuICpcbiAqIEB0eXBlZGVmIEhpZGRlblByZXByb2Nlc3NvclxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBodG1sXG4gKiBAcHJvcGVydHkge251bWJlcn0gcG9zXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGFzdEdhcFBvc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxhc3RDaGFyUG9zXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGdhcFN0YWNrXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNraXBOZXh0TmV3TGluZVxuICogQHByb3BlcnR5IHtib29sZWFufSBsYXN0Q2h1bmtXcml0dGVuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuZE9mQ2h1bmtIaXRcbiAqXG4gKiBAdHlwZWRlZiBIaWRkZW5Mb2NhdGlvblRyYWNrZXJcbiAqIEBwcm9wZXJ0eSB7UDVMb2NhdGlvbnx1bmRlZmluZWR9IGN1cnJlbnRBdHRyTG9jYXRpb25cbiAqIEBwcm9wZXJ0eSB7UDVMb2NhdGlvbn0gY3RMb2NcbiAqIEBwcm9wZXJ0eSB7SGlkZGVuUG9zVHJhY2tlcn0gcG9zVHJhY2tlclxuICpcbiAqIEB0eXBlZGVmIEhpZGRlblBvc1RyYWNrZXJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNFb2xcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lU3RhcnRQb3NcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkcm9wcGVkQnVmZmVyU2l6ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmVcbiAqL1xuXG4vLyBAdHMtZXhwZWN0LWVycm9yOiB1bnR5cGVkLlxuaW1wb3J0IFBhcnNlciBmcm9tICdwYXJzZTUvbGliL3BhcnNlci9pbmRleC5qcydcbmltcG9ydCB7cG9pbnRTdGFydCwgcG9pbnRFbmR9IGZyb20gJ3VuaXN0LXV0aWwtcG9zaXRpb24nXG5pbXBvcnQge3Zpc2l0fSBmcm9tICd1bmlzdC11dGlsLXZpc2l0J1xuaW1wb3J0IHtmcm9tUGFyc2U1fSBmcm9tICdoYXN0LXV0aWwtZnJvbS1wYXJzZTUnXG5pbXBvcnQge3RvUGFyc2U1fSBmcm9tICdoYXN0LXV0aWwtdG8tcGFyc2U1J1xuaW1wb3J0IHtodG1sVm9pZEVsZW1lbnRzfSBmcm9tICdodG1sLXZvaWQtZWxlbWVudHMnXG5pbXBvcnQge3dlYk5hbWVzcGFjZXN9IGZyb20gJ3dlYi1uYW1lc3BhY2VzJ1xuaW1wb3J0IHt6d2l0Y2h9IGZyb20gJ3p3aXRjaCdcblxuY29uc3QgaW5UZW1wbGF0ZU1vZGUgPSAnSU5fVEVNUExBVEVfTU9ERSdcbmNvbnN0IGRhdGFTdGF0ZSA9ICdEQVRBX1NUQVRFJ1xuY29uc3QgY2hhcmFjdGVyVG9rZW4gPSAnQ0hBUkFDVEVSX1RPS0VOJ1xuY29uc3Qgc3RhcnRUYWdUb2tlbiA9ICdTVEFSVF9UQUdfVE9LRU4nXG5jb25zdCBlbmRUYWdUb2tlbiA9ICdFTkRfVEFHX1RPS0VOJ1xuY29uc3QgY29tbWVudFRva2VuID0gJ0NPTU1FTlRfVE9LRU4nXG5jb25zdCBkb2N0eXBlVG9rZW4gPSAnRE9DVFlQRV9UT0tFTidcblxuLyoqIEB0eXBlIHtQNVBhcnNlck9wdGlvbnN9ICovXG5jb25zdCBwYXJzZU9wdGlvbnMgPSB7c291cmNlQ29kZUxvY2F0aW9uSW5mbzogdHJ1ZSwgc2NyaXB0aW5nRW5hYmxlZDogZmFsc2V9XG5cbi8qKlxuICogR2l2ZW4gYSBoYXN0IHRyZWUgYW5kIGFuIG9wdGlvbmFsIHZmaWxlIChmb3IgcG9zaXRpb25hbCBpbmZvKSwgcmV0dXJuIGEgbmV3XG4gKiBwYXJzZWQtYWdhaW4gaGFzdCB0cmVlLlxuICpcbiAqIEBwYXJhbSB0cmVlXG4gKiAgIE9yaWdpbmFsIGhhc3QgdHJlZS5cbiAqIEBwYXJhbSBmaWxlXG4gKiAgIFZpcnR1YWwgZmlsZSBmb3IgcG9zaXRpb25hbCBpbmZvLCBvcHRpb25hbC5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCByYXcgPVxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoKHRyZWU6IE5vZGUsIGZpbGU6IFZGaWxlfHVuZGVmaW5lZCwgb3B0aW9ucz86IE9wdGlvbnMpID0+IE5vZGUpICZcbiAgICogICAoKHRyZWU6IE5vZGUsIG9wdGlvbnM/OiBPcHRpb25zKSA9PiBOb2RlKVxuICAgKiApfVxuICAgKi9cbiAgKFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICAgICAqIEBwYXJhbSB7VkZpbGV9IFtmaWxlXVxuICAgICAqIEBwYXJhbSB7T3B0aW9uc30gW29wdGlvbnNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRyZWUsIGZpbGUsIG9wdGlvbnMpIHtcbiAgICAgIGxldCBpbmRleCA9IC0xXG4gICAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHBhcnNlT3B0aW9ucylcbiAgICAgIGNvbnN0IG9uZSA9IHp3aXRjaCgndHlwZScsIHtcbiAgICAgICAgaGFuZGxlcnM6IHtyb290LCBlbGVtZW50LCB0ZXh0LCBjb21tZW50LCBkb2N0eXBlLCByYXc6IGhhbmRsZVJhd30sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGh1c2guXG4gICAgICAgIHVua25vd25cbiAgICAgIH0pXG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHN0aXRjaGVzXG4gICAgICAvKiogQHR5cGUge0hpZGRlblRva2VuaXplcnx1bmRlZmluZWR9ICovXG4gICAgICBsZXQgdG9rZW5pemVyXG4gICAgICAvKiogQHR5cGUge0hpZGRlblByZXByb2Nlc3Nvcnx1bmRlZmluZWR9ICovXG4gICAgICBsZXQgcHJlcHJvY2Vzc29yXG4gICAgICAvKiogQHR5cGUge0hpZGRlblBvc1RyYWNrZXJ8dW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHBvc1RyYWNrZXJcbiAgICAgIC8qKiBAdHlwZSB7SGlkZGVuTG9jYXRpb25UcmFja2VyfHVuZGVmaW5lZH0gKi9cbiAgICAgIGxldCBsb2NhdGlvblRyYWNrZXJcblxuICAgICAgaWYgKGlzT3B0aW9ucyhmaWxlKSkge1xuICAgICAgICBvcHRpb25zID0gZmlsZVxuICAgICAgICBmaWxlID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGFzc1Rocm91Z2gpIHtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBvcHRpb25zLnBhc3NUaHJvdWdoLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGh1c2guXG4gICAgICAgICAgb25lLmhhbmRsZXJzW29wdGlvbnMucGFzc1Rocm91Z2hbaW5kZXhdXSA9IHN0aXRjaFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZyb21QYXJzZTUoXG4gICAgICAgIGRvY3VtZW50TW9kZSh0cmVlKSA/IGRvY3VtZW50KCkgOiBmcmFnbWVudCgpLFxuICAgICAgICBmaWxlXG4gICAgICApXG5cbiAgICAgIGlmIChzdGl0Y2hlcykge1xuICAgICAgICB2aXNpdChyZXN1bHQsICdjb21tZW50JywgKG5vZGUsIGluZGV4LCBwYXJlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGl0Y2ggPSAvKiogQHR5cGUge1N0aXRjaH0gKi8gKC8qKiBAdHlwZSB7dW5rbm93bn0gKi8gKG5vZGUpKVxuICAgICAgICAgIGlmIChzdGl0Y2gudmFsdWUuc3RpdGNoICYmIHBhcmVudCAhPT0gbnVsbCAmJiBpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYXNzdW1lIHRoZSBzdGl0Y2ggaXMgYWxsb3dlZC5cbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleF0gPSBzdGl0Y2gudmFsdWUuc3RpdGNoXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIFVucGFjayBpZiBwb3NzaWJsZSBhbmQgd2hlbiBub3QgZ2l2ZW4gYSBgcm9vdGAuXG4gICAgICBpZiAoXG4gICAgICAgIHRyZWUudHlwZSAhPT0gJ3Jvb3QnICYmXG4gICAgICAgIHJlc3VsdC50eXBlID09PSAncm9vdCcgJiZcbiAgICAgICAgcmVzdWx0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuY2hpbGRyZW5bMF1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuXG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIHtQNUZyYWdtZW50fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBmcmFnbWVudCgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQNUVsZW1lbnR9ICovXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgbm9kZU5hbWU6ICd0ZW1wbGF0ZScsXG4gICAgICAgICAgdGFnTmFtZTogJ3RlbXBsYXRlJyxcbiAgICAgICAgICBhdHRyczogW10sXG4gICAgICAgICAgbmFtZXNwYWNlVVJJOiB3ZWJOYW1lc3BhY2VzLmh0bWwsXG4gICAgICAgICAgY2hpbGROb2RlczogW11cbiAgICAgICAgfVxuICAgICAgICAvKiogQHR5cGUge1A1RWxlbWVudH0gKi9cbiAgICAgICAgY29uc3QgbW9jayA9IHtcbiAgICAgICAgICBub2RlTmFtZTogJ2RvY3VtZW50bW9jaycsXG4gICAgICAgICAgdGFnTmFtZTogJ2RvY3VtZW50bW9jaycsXG4gICAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICAgIG5hbWVzcGFjZVVSSTogd2ViTmFtZXNwYWNlcy5odG1sLFxuICAgICAgICAgIGNoaWxkTm9kZXM6IFtdXG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHtQNUZyYWdtZW50fSAqL1xuICAgICAgICBjb25zdCBkb2MgPSB7bm9kZU5hbWU6ICcjZG9jdW1lbnQtZnJhZ21lbnQnLCBjaGlsZE5vZGVzOiBbXX1cblxuICAgICAgICBwYXJzZXIuX2Jvb3RzdHJhcChtb2NrLCBjb250ZXh0KVxuICAgICAgICBwYXJzZXIuX3B1c2hUbXBsSW5zZXJ0aW9uTW9kZShpblRlbXBsYXRlTW9kZSlcbiAgICAgICAgcGFyc2VyLl9pbml0VG9rZW5pemVyRm9yRnJhZ21lbnRQYXJzaW5nKClcbiAgICAgICAgcGFyc2VyLl9pbnNlcnRGYWtlUm9vdEVsZW1lbnQoKVxuICAgICAgICBwYXJzZXIuX3Jlc2V0SW5zZXJ0aW9uTW9kZSgpXG4gICAgICAgIHBhcnNlci5fZmluZEZvcm1JbkZyYWdtZW50Q29udGV4dCgpXG5cbiAgICAgICAgdG9rZW5pemVyID0gcGFyc2VyLnRva2VuaXplclxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoIXRva2VuaXplcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgdG9rZW5pemVyYCcpXG4gICAgICAgIHByZXByb2Nlc3NvciA9IHRva2VuaXplci5wcmVwcm9jZXNzb3JcbiAgICAgICAgbG9jYXRpb25UcmFja2VyID0gdG9rZW5pemVyLl9fbWl4aW5zWzBdXG4gICAgICAgIHBvc1RyYWNrZXIgPSBsb2NhdGlvblRyYWNrZXIucG9zVHJhY2tlclxuXG4gICAgICAgIG9uZSh0cmVlKVxuXG4gICAgICAgIHJlc2V0VG9rZW5pemVyKClcblxuICAgICAgICBwYXJzZXIuX2Fkb3B0Tm9kZXMobW9jay5jaGlsZE5vZGVzWzBdLCBkb2MpXG5cbiAgICAgICAgcmV0dXJuIGRvY1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIHtQNURvY3VtZW50fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBkb2N1bWVudCgpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQNURvY3VtZW50fSAqL1xuICAgICAgICBjb25zdCBkb2MgPSBwYXJzZXIudHJlZUFkYXB0ZXIuY3JlYXRlRG9jdW1lbnQoKVxuXG4gICAgICAgIHBhcnNlci5fYm9vdHN0cmFwKGRvYywgdW5kZWZpbmVkKVxuICAgICAgICB0b2tlbml6ZXIgPSBwYXJzZXIudG9rZW5pemVyXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmICghdG9rZW5pemVyKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGB0b2tlbml6ZXJgJylcbiAgICAgICAgcHJlcHJvY2Vzc29yID0gdG9rZW5pemVyLnByZXByb2Nlc3NvclxuICAgICAgICBsb2NhdGlvblRyYWNrZXIgPSB0b2tlbml6ZXIuX19taXhpbnNbMF1cbiAgICAgICAgcG9zVHJhY2tlciA9IGxvY2F0aW9uVHJhY2tlci5wb3NUcmFja2VyXG5cbiAgICAgICAgb25lKHRyZWUpXG5cbiAgICAgICAgcmVzZXRUb2tlbml6ZXIoKVxuXG4gICAgICAgIHJldHVybiBkb2NcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0FycmF5PENvbnRlbnQ+fSBub2Rlc1xuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGFsbChub2Rlcykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gaW52YWxpZCBub2Rlcywgc2VlIHJlaHlwZWpzL3JlaHlwZS1yYXcjNy4gKi9cbiAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9uZShub2Rlc1tpbmRleF0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtSb290fSBub2RlXG4gICAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gcm9vdChub2RlKSB7XG4gICAgICAgIGFsbChub2RlLmNoaWxkcmVuKVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGVsZW1lbnQobm9kZSkge1xuICAgICAgICByZXNldFRva2VuaXplcigpXG4gICAgICAgIHBhcnNlci5fcHJvY2Vzc0lucHV0VG9rZW4oc3RhcnRUYWcobm9kZSkpXG5cbiAgICAgICAgYWxsKG5vZGUuY2hpbGRyZW4pXG5cbiAgICAgICAgaWYgKCFodG1sVm9pZEVsZW1lbnRzLmluY2x1ZGVzKG5vZGUudGFnTmFtZSkpIHtcbiAgICAgICAgICByZXNldFRva2VuaXplcigpXG4gICAgICAgICAgcGFyc2VyLl9wcm9jZXNzSW5wdXRUb2tlbihlbmRUYWcobm9kZSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1RleHR9IG5vZGVcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiB0ZXh0KG5vZGUpIHtcbiAgICAgICAgcmVzZXRUb2tlbml6ZXIoKVxuICAgICAgICBwYXJzZXIuX3Byb2Nlc3NJbnB1dFRva2VuKHtcbiAgICAgICAgICB0eXBlOiBjaGFyYWN0ZXJUb2tlbixcbiAgICAgICAgICBjaGFyczogbm9kZS52YWx1ZSxcbiAgICAgICAgICBsb2NhdGlvbjogY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0RvY3R5cGV9IG5vZGVcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBkb2N0eXBlKG5vZGUpIHtcbiAgICAgICAgcmVzZXRUb2tlbml6ZXIoKVxuICAgICAgICBwYXJzZXIuX3Byb2Nlc3NJbnB1dFRva2VuKHtcbiAgICAgICAgICB0eXBlOiBkb2N0eXBlVG9rZW4sXG4gICAgICAgICAgbmFtZTogJ2h0bWwnLFxuICAgICAgICAgIGZvcmNlUXVpcmtzOiBmYWxzZSxcbiAgICAgICAgICBwdWJsaWNJZDogJycsXG4gICAgICAgICAgc3lzdGVtSWQ6ICcnLFxuICAgICAgICAgIGxvY2F0aW9uOiBjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Q29tbWVudHxTdGl0Y2h9IG5vZGVcbiAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBjb21tZW50KG5vZGUpIHtcbiAgICAgICAgcmVzZXRUb2tlbml6ZXIoKVxuICAgICAgICBwYXJzZXIuX3Byb2Nlc3NJbnB1dFRva2VuKHtcbiAgICAgICAgICB0eXBlOiBjb21tZW50VG9rZW4sXG4gICAgICAgICAgZGF0YTogbm9kZS52YWx1ZSxcbiAgICAgICAgICBsb2NhdGlvbjogY3JlYXRlUGFyc2U1TG9jYXRpb24obm9kZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1Jhd30gbm9kZVxuICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVJhdyhub2RlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcG9pbnRTdGFydChub2RlKVxuICAgICAgICBjb25zdCBsaW5lID0gc3RhcnQubGluZSB8fCAxXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHN0YXJ0LmNvbHVtbiB8fCAxXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0Lm9mZnNldCB8fCAwXG5cbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgNCAqL1xuICAgICAgICBpZiAoIXByZXByb2Nlc3NvcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgcHJlcHJvY2Vzc29yYCcpXG4gICAgICAgIGlmICghdG9rZW5pemVyKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGB0b2tlbml6ZXJgJylcbiAgICAgICAgaWYgKCFwb3NUcmFja2VyKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGBwb3NUcmFja2VyYCcpXG4gICAgICAgIGlmICghbG9jYXRpb25UcmFja2VyKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGBsb2NhdGlvblRyYWNrZXJgJylcblxuICAgICAgICAvLyBSZXNldCBwcmVwcm9jZXNzb3I6XG4gICAgICAgIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmlrdWxpbi9wYXJzZTUvYmxvYi85YzY4M2UxL3BhY2thZ2VzL3BhcnNlNS9saWIvdG9rZW5pemVyL3ByZXByb2Nlc3Nvci5qcyNMMTc+LlxuICAgICAgICBwcmVwcm9jZXNzb3IuaHRtbCA9IHVuZGVmaW5lZFxuICAgICAgICBwcmVwcm9jZXNzb3IucG9zID0gLTFcbiAgICAgICAgcHJlcHJvY2Vzc29yLmxhc3RHYXBQb3MgPSAtMVxuICAgICAgICBwcmVwcm9jZXNzb3IubGFzdENoYXJQb3MgPSAtMVxuICAgICAgICBwcmVwcm9jZXNzb3IuZ2FwU3RhY2sgPSBbXVxuICAgICAgICBwcmVwcm9jZXNzb3Iuc2tpcE5leHROZXdMaW5lID0gZmFsc2VcbiAgICAgICAgcHJlcHJvY2Vzc29yLmxhc3RDaHVua1dyaXR0ZW4gPSBmYWxzZVxuICAgICAgICBwcmVwcm9jZXNzb3IuZW5kT2ZDaHVua0hpdCA9IGZhbHNlXG5cbiAgICAgICAgLy8gUmVzZXQgcHJlcHJvY2Vzc29yIG1peGluOlxuICAgICAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvOWM2ODNlMS9wYWNrYWdlcy9wYXJzZTUvbGliL2V4dGVuc2lvbnMvcG9zaXRpb24tdHJhY2tpbmcvcHJlcHJvY2Vzc29yLW1peGluLmpzPi5cbiAgICAgICAgcG9zVHJhY2tlci5pc0VvbCA9IGZhbHNlXG4gICAgICAgIHBvc1RyYWNrZXIubGluZVN0YXJ0UG9zID0gLWNvbHVtbiArIDEgLy8gTG9va3Mgd2VpcmQsIGJ1dCBlbnN1cmVzIHdlIGdldCBjb3JyZWN0IHBvc2l0aW9uYWwgaW5mby5cbiAgICAgICAgcG9zVHJhY2tlci5kcm9wcGVkQnVmZmVyU2l6ZSA9IG9mZnNldFxuICAgICAgICBwb3NUcmFja2VyLm9mZnNldCA9IDBcbiAgICAgICAgcG9zVHJhY2tlci5jb2wgPSAxXG4gICAgICAgIHBvc1RyYWNrZXIubGluZSA9IGxpbmVcblxuICAgICAgICAvLyBSZXNldCBsb2NhdGlvbiB0cmFja2VyOlxuICAgICAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvOWM2ODNlMS9wYWNrYWdlcy9wYXJzZTUvbGliL2V4dGVuc2lvbnMvbG9jYXRpb24taW5mby90b2tlbml6ZXItbWl4aW4uanM+LlxuICAgICAgICBsb2NhdGlvblRyYWNrZXIuY3VycmVudEF0dHJMb2NhdGlvbiA9IHVuZGVmaW5lZFxuICAgICAgICBsb2NhdGlvblRyYWNrZXIuY3RMb2MgPSBjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKVxuXG4gICAgICAgIC8vIFNlZSB0aGUgY29kZSBmb3IgYHBhcnNlYCBhbmQgYHBhcnNlRnJhZ21lbnRgOlxuICAgICAgICAvLyBTZWU6IDxodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vcGFyc2U1L2Jsb2IvOWM2ODNlMS9wYWNrYWdlcy9wYXJzZTUvbGliL3BhcnNlci9pbmRleC5qcyNMMzcxPi5cbiAgICAgICAgdG9rZW5pemVyLndyaXRlKG5vZGUudmFsdWUpXG4gICAgICAgIHBhcnNlci5fcnVuUGFyc2luZ0xvb3AobnVsbClcblxuICAgICAgICAvLyBDaGFyYWN0ZXIgcmVmZXJlbmNlcyBoYW5nLCBzbyBpZiB3ZSBlbmRlZCB0aGVyZSwgd2UgbmVlZCB0byBmbHVzaFxuICAgICAgICAvLyB0aG9zZSB0b28uXG4gICAgICAgIC8vIFdlIHJlc2V0IHRoZSBwcmVwcm9jZXNzb3IgYXMgaWYgdGhlIGRvY3VtZW50IGVuZHMgaGVyZS5cbiAgICAgICAgLy8gVGhlbiBvbmUgc2luZ2xlIGNhbGwgdG8gdGhlIHJlbGV2YW50IHN0YXRlIGRvZXMgdGhlIHRyaWNrLCBwYXJzZTVcbiAgICAgICAgLy8gY29uc3VtZXMgdGhlIHdob2xlIHRva2VuLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdG9rZW5pemVyLnN0YXRlID09PSAnTkFNRURfQ0hBUkFDVEVSX1JFRkVSRU5DRV9TVEFURScgfHxcbiAgICAgICAgICB0b2tlbml6ZXIuc3RhdGUgPT09ICdOVU1FUklDX0NIQVJBQ1RFUl9SRUZFUkVOQ0VfRU5EX1NUQVRFJ1xuICAgICAgICApIHtcbiAgICAgICAgICBwcmVwcm9jZXNzb3IubGFzdENodW5rV3JpdHRlbiA9IHRydWVcbiAgICAgICAgICB0b2tlbml6ZXJbdG9rZW5pemVyLnN0YXRlXSh0b2tlbml6ZXIuX2NvbnN1bWUoKSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzdGl0Y2gobm9kZSkge1xuICAgICAgICBzdGl0Y2hlcyA9IHRydWVcblxuICAgICAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgICAgIGxldCBjbG9uZVxuXG4gICAgICAgIC8vIFJlY3Vyc2UsIGJlY2F1c2UgdG8gc29tZXdoYXQgaGFuZGxlIGBbPHg+XTwveD5gICh3aGVyZSBgW11gIGRlbm90ZXMgdGhlXG4gICAgICAgIC8vIHBhc3NlZCB0aHJvdWdoIG5vZGUpLlxuICAgICAgICBpZiAoJ2NoaWxkcmVuJyBpbiBub2RlKSB7XG4gICAgICAgICAgY2xvbmUgPSB7XG4gICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgY2hpbGRyZW46IHJhdyhcbiAgICAgICAgICAgICAge3R5cGU6ICdyb290JywgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW59LFxuICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQXNzdW1lIGEgZ2l2ZW4gcGFyZW50IHlpZWxkcyBhIHBhcmVudC5cbiAgICAgICAgICAgICkuY2hpbGRyZW5cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmUgPSB7Li4ubm9kZX1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhY2s6IGB2YWx1ZWAgaXMgc3VwcG9zZWQgdG8gYmUgYSBzdHJpbmcsIGJ1dCBhcyBub25lIG9mIHRoZSB0b29sc1xuICAgICAgICAvLyAoYHBhcnNlNWAgb3IgYGhhc3QtdXRpbC1mcm9tLXBhcnNlNWApIGxvb2tzIGF0IGl0LCB3ZSBjYW4gcGFzcyBub2Rlc1xuICAgICAgICAvLyB0aHJvdWdoLlxuICAgICAgICBjb21tZW50KHt0eXBlOiAnY29tbWVudCcsIHZhbHVlOiB7c3RpdGNoOiBjbG9uZX19KVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZXNldFRva2VuaXplcigpIHtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqL1xuICAgICAgICBpZiAoIXRva2VuaXplcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgdG9rZW5pemVyYCcpXG4gICAgICAgIGlmICghcG9zVHJhY2tlcikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBgcG9zVHJhY2tlcmAnKVxuXG4gICAgICAgIC8vIFByb2Nlc3MgZmluYWwgY2hhcmFjdGVycyBpZiB0aGV54oCZcmUgc3RpbGwgdGhlcmUgYWZ0ZXIgaGliZXJuYXRpbmcuXG4gICAgICAgIC8vIFNpbWlsYXIgdG86XG4gICAgICAgIC8vIFNlZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9pbmlrdWxpbi9wYXJzZTUvYmxvYi85YzY4M2UxL3BhY2thZ2VzL3BhcnNlNS9saWIvZXh0ZW5zaW9ucy9sb2NhdGlvbi1pbmZvL3Rva2VuaXplci1taXhpbi5qcyNMOTU+LlxuICAgICAgICBjb25zdCB0b2tlbiA9IHRva2VuaXplci5jdXJyZW50Q2hhcmFjdGVyVG9rZW5cblxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICB0b2tlbi5sb2NhdGlvbi5lbmRMaW5lID0gcG9zVHJhY2tlci5saW5lXG4gICAgICAgICAgdG9rZW4ubG9jYXRpb24uZW5kQ29sID0gcG9zVHJhY2tlci5jb2wgKyAxXG4gICAgICAgICAgdG9rZW4ubG9jYXRpb24uZW5kT2Zmc2V0ID0gcG9zVHJhY2tlci5vZmZzZXQgKyAxXG4gICAgICAgICAgcGFyc2VyLl9wcm9jZXNzSW5wdXRUb2tlbih0b2tlbilcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHRva2VuaXplcjpcbiAgICAgICAgLy8gU2VlOiA8aHR0cHM6Ly9naXRodWIuY29tL2luaWt1bGluL3BhcnNlNS9ibG9iLzljNjgzZTEvcGFja2FnZXMvcGFyc2U1L2xpYi90b2tlbml6ZXIvaW5kZXguanMjTDIxOC1MMjM0Pi5cbiAgICAgICAgLy8gRXNwZWNpYWxseSBwdXR0aW5nIGl0IGJhY2sgaW4gdGhlIGBkYXRhYCBzdGF0ZSBpcyB1c2VmdWw6IHNvbWUgZWxlbWVudHMsXG4gICAgICAgIC8vIGxpa2UgdGV4dGFyZWFzIGFuZCBpZnJhbWVzLCBjaGFuZ2UgdGhlIHN0YXRlLlxuICAgICAgICAvLyBTZWUgR0gtNy5cbiAgICAgICAgLy8gQnV0IGFsc28gaWYgYnJva2VuIEhUTUwgaXMgaW4gYHJhd2AsIGFuZCB0aGVuIGEgY29ycmVjdCBlbGVtZW50IGlzIGdpdmVuLlxuICAgICAgICAvLyBTZWUgR0gtMTEuXG4gICAgICAgIHRva2VuaXplci50b2tlblF1ZXVlID0gW11cbiAgICAgICAgdG9rZW5pemVyLnN0YXRlID0gZGF0YVN0YXRlXG4gICAgICAgIHRva2VuaXplci5yZXR1cm5TdGF0ZSA9ICcnXG4gICAgICAgIHRva2VuaXplci5jaGFyUmVmQ29kZSA9IC0xXG4gICAgICAgIHRva2VuaXplci50ZW1wQnVmZiA9IFtdXG4gICAgICAgIHRva2VuaXplci5sYXN0U3RhcnRUYWdOYW1lID0gJydcbiAgICAgICAgdG9rZW5pemVyLmNvbnN1bWVkQWZ0ZXJTbmFwc2hvdCA9IC0xXG4gICAgICAgIHRva2VuaXplci5hY3RpdmUgPSBmYWxzZVxuICAgICAgICB0b2tlbml6ZXIuY3VycmVudENoYXJhY3RlclRva2VuID0gdW5kZWZpbmVkXG4gICAgICAgIHRva2VuaXplci5jdXJyZW50VG9rZW4gPSB1bmRlZmluZWRcbiAgICAgICAgdG9rZW5pemVyLmN1cnJlbnRBdHRyID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuICApXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0hpZGRlblRva2VufVxuICovXG5mdW5jdGlvbiBzdGFydFRhZyhub2RlKSB7XG4gIC8qKiBAdHlwZSB7UDVMb2NhdGlvbn0gKi9cbiAgY29uc3QgbG9jYXRpb24gPSBPYmplY3QuYXNzaWduKGNyZWF0ZVBhcnNlNUxvY2F0aW9uKG5vZGUpKVxuICAvLyBAdHMtZXhwZWN0LWVycm9yIGV4dHJhIHBvc2l0aW9uYWwgaW5mby5cbiAgbG9jYXRpb24uc3RhcnRUYWcgPSBPYmplY3QuYXNzaWduKHt9LCBsb2NhdGlvbilcblxuICAvLyBVbnR5cGVkIHRva2VuLlxuICByZXR1cm4ge1xuICAgIHR5cGU6IHN0YXJ0VGFnVG9rZW4sXG4gICAgdGFnTmFtZTogbm9kZS50YWdOYW1lLFxuICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICBhdHRyczogYXR0cmlidXRlcyhub2RlKSxcbiAgICBsb2NhdGlvblxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7QXJyYXk8UDVBdHRyaWJ1dGU+fVxuICovXG5mdW5jdGlvbiBhdHRyaWJ1dGVzKG5vZGUpIHtcbiAgcmV0dXJuIHRvUGFyc2U1KHtcbiAgICB0YWdOYW1lOiBub2RlLnRhZ05hbWUsXG4gICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgIHByb3BlcnRpZXM6IG5vZGUucHJvcGVydGllcyxcbiAgICBjaGlsZHJlbjogW11cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEFzc3VtZSBlbGVtZW50LlxuICB9KS5hdHRyc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0hpZGRlblRva2VufVxuICovXG5mdW5jdGlvbiBlbmRUYWcobm9kZSkge1xuICAvKiogQHR5cGUge1A1TG9jYXRpb259ICovXG4gIGNvbnN0IGxvY2F0aW9uID0gT2JqZWN0LmFzc2lnbihjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKSlcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBleHRyYSBwb3NpdGlvbmFsIGluZm8uXG4gIGxvY2F0aW9uLnN0YXJ0VGFnID0gT2JqZWN0LmFzc2lnbih7fSwgbG9jYXRpb24pXG5cbiAgLy8gVW50eXBlZCB0b2tlbi5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBlbmRUYWdUb2tlbixcbiAgICB0YWdOYW1lOiBub2RlLnRhZ05hbWUsXG4gICAgYXR0cnM6IFtdLFxuICAgIGxvY2F0aW9uXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqL1xuZnVuY3Rpb24gdW5rbm93bihub2RlKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBpbGUgYCcgKyBub2RlLnR5cGUgKyAnYCBub2RlJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBkb2N1bWVudE1vZGUobm9kZSkge1xuICBjb25zdCBoZWFkID0gbm9kZS50eXBlID09PSAncm9vdCcgPyBub2RlLmNoaWxkcmVuWzBdIDogbm9kZVxuICByZXR1cm4gQm9vbGVhbihcbiAgICBoZWFkICYmXG4gICAgICAoaGVhZC50eXBlID09PSAnZG9jdHlwZScgfHxcbiAgICAgICAgKGhlYWQudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGhlYWQudGFnTmFtZSA9PT0gJ2h0bWwnKSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZXxTdGl0Y2h9IG5vZGVcbiAqIEByZXR1cm5zIHtQNUxvY2F0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJzZTVMb2NhdGlvbihub2RlKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcG9pbnRTdGFydChub2RlKVxuICBjb25zdCBlbmQgPSBwb2ludEVuZChub2RlKVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRMaW5lOiBzdGFydC5saW5lLFxuICAgIHN0YXJ0Q29sOiBzdGFydC5jb2x1bW4sXG4gICAgc3RhcnRPZmZzZXQ6IHN0YXJ0Lm9mZnNldCxcbiAgICBlbmRMaW5lOiBlbmQubGluZSxcbiAgICBlbmRDb2w6IGVuZC5jb2x1bW4sXG4gICAgZW5kT2Zmc2V0OiBlbmQub2Zmc2V0XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZGaWxlfE9wdGlvbnN8dW5kZWZpbmVkfSB2YWx1ZVxuICogQHJldHVybiB7dmFsdWUgaXMgT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gaXNPcHRpb25zKHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlICYmICEoJ21lc3NhZ2UnIGluIHZhbHVlICYmICdtZXNzYWdlcycgaW4gdmFsdWUpKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hast-util-raw/lib/index.js\n");

/***/ })

};
;